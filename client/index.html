<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#22c55e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="MESS">
  <link rel="manifest" href="./manifest.json">
  <link rel="apple-touch-icon" href="./icons/icon-192.png">
  <title>MESS</title>
  <script src="https://unpkg.com/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --mess-50: #f0fdf4; --mess-100: #dcfce7; --mess-200: #bbf7d0;
      --mess-300: #86efac; --mess-400: #4ade80; --mess-500: #22c55e;
      --mess-600: #16a34a; --mess-700: #15803d; --mess-800: #166534;
      --mess-900: #14532d;
      --bg: #f9fafb; --bg-card: #ffffff; --bg-hover: #f3f4f6;
      --text: #111827; --text-secondary: #6b7280; --text-muted: #9ca3af;
      --border: #e5e7eb; --border-light: #f3f4f6;
    }
    [data-theme="dark"] {
      --bg: #0f172a; --bg-card: #1e293b; --bg-hover: #334155;
      --text: #f1f5f9; --text-secondary: #94a3b8; --text-muted: #64748b;
      --border: #334155; --border-light: #1e293b;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg); color: var(--text);
      min-height: 100vh; transition: background 0.3s, color 0.3s;
    }
    .mono { font-family: 'JetBrains Mono', Menlo, monospace; }
    
    /* Animations */
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .animate-fade { animation: fadeIn 0.3s ease-out; }
    .animate-slide { animation: slideUp 0.3s ease-out; }
    .loading { animation: pulse 1.5s infinite; }
    
    /* Layout */
    .container { max-width: 32rem; margin: 0 auto; padding: 1rem; }
    .flex { display: flex; } .flex-col { flex-direction: column; }
    .items-center { align-items: center; } .justify-center { justify-content: center; }
    .justify-between { justify-content: space-between; }
    .gap-1 { gap: 0.25rem; } .gap-2 { gap: 0.5rem; } .gap-3 { gap: 0.75rem; } .gap-4 { gap: 1rem; }
    .flex-1 { flex: 1; } .flex-wrap { flex-wrap: wrap; }
    .w-full { width: 100%; } .min-w-0 { min-width: 0; }
    .h-screen { height: 100vh; } .min-h-screen { min-height: 100vh; }
    .overflow-y-auto { overflow-y: auto; } .overflow-x-auto { overflow-x: auto; }
    .hidden { display: none !important; }
    .shrink-0 { flex-shrink: 0; }
    
    /* Spacing */
    .p-2 { padding: 0.5rem; } .p-3 { padding: 0.75rem; } .p-4 { padding: 1rem; } 
    .p-5 { padding: 1.25rem; } .p-6 { padding: 1.5rem; } .p-8 { padding: 2rem; }
    .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
    .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
    .px-4 { padding-left: 1rem; padding-right: 1rem; }
    .px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }
    .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
    .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
    .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
    .pt-4 { padding-top: 1rem; } .pt-8 { padding-top: 2rem; } .pt-12 { padding-top: 3rem; }
    .pb-4 { padding-bottom: 1rem; } .pb-8 { padding-bottom: 2rem; } .pb-24 { padding-bottom: 6rem; }
    .mb-1 { margin-bottom: 0.25rem; } .mb-2 { margin-bottom: 0.5rem; } 
    .mb-3 { margin-bottom: 0.75rem; } .mb-4 { margin-bottom: 1rem; }
    .mb-6 { margin-bottom: 1.5rem; } .mb-8 { margin-bottom: 2rem; } .mb-10 { margin-bottom: 2.5rem; }
    .mt-1 { margin-top: 0.25rem; } .mt-2 { margin-top: 0.5rem; } .mt-3 { margin-top: 0.75rem; }
    .ml-8 { margin-left: 2rem; }
    .space-y-2 > * + * { margin-top: 0.5rem; }
    .space-y-3 > * + * { margin-top: 0.75rem; }
    .space-y-4 > * + * { margin-top: 1rem; }
    .space-y-6 > * + * { margin-top: 1.5rem; }
    
    /* Typography */
    .text-xs { font-size: 0.75rem; } .text-sm { font-size: 0.875rem; }
    .text-lg { font-size: 1.125rem; } .text-xl { font-size: 1.25rem; }
    .text-2xl { font-size: 1.5rem; } .text-4xl { font-size: 2.25rem; }
    .font-medium { font-weight: 500; } .font-semibold { font-weight: 600; } .font-bold { font-weight: 700; }
    .text-center { text-align: center; }
    .truncate { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .whitespace-nowrap { white-space: nowrap; }
    .whitespace-pre-wrap { white-space: pre-wrap; }
    .capitalize { text-transform: capitalize; }
    .italic { font-style: italic; }
    
    /* Colors */
    .text-primary { color: var(--text); }
    .text-secondary { color: var(--text-secondary); }
    .text-muted { color: var(--text-muted); }
    .text-mess { color: var(--mess-600); }
    [data-theme="dark"] .text-mess { color: var(--mess-400); }
    .text-red { color: #dc2626; } .text-amber { color: #d97706; }
    .text-blue { color: #2563eb; } .text-purple { color: #7c3aed; }
    .text-green { color: #16a34a; } .text-white { color: white; }
    
    /* Backgrounds */
    .bg-page { background: var(--bg); }
    .bg-card { background: var(--bg-card); }
    .bg-hover { background: var(--bg-hover); }
    .bg-mess { background: var(--mess-500); }
    .bg-mess-light { background: var(--mess-50); }
    [data-theme="dark"] .bg-mess-light { background: rgba(34, 197, 94, 0.15); }
    .bg-blue-light { background: #dbeafe; }
    [data-theme="dark"] .bg-blue-light { background: rgba(37, 99, 235, 0.2); }
    .bg-amber-light { background: #fef3c7; }
    [data-theme="dark"] .bg-amber-light { background: rgba(217, 119, 6, 0.2); }
    .bg-red-light { background: #fee2e2; }
    [data-theme="dark"] .bg-red-light { background: rgba(220, 38, 38, 0.2); }
    .bg-purple-light { background: #ede9fe; }
    [data-theme="dark"] .bg-purple-light { background: rgba(124, 58, 237, 0.2); }
    .bg-gray-light { background: #f3f4f6; }
    [data-theme="dark"] .bg-gray-light { background: #374151; }
    
    /* Borders */
    .border { border: 1px solid var(--border); }
    .border-t { border-top: 1px solid var(--border); }
    .border-b { border-bottom: 1px solid var(--border); }
    .border-2 { border-width: 2px; }
    .border-mess { border-color: var(--mess-300); }
    .border-red { border-color: #fca5a5; }
    .border-purple { border-color: #c4b5fd; }
    .rounded { border-radius: 0.375rem; }
    .rounded-lg { border-radius: 0.5rem; }
    .rounded-xl { border-radius: 0.75rem; }
    .rounded-2xl { border-radius: 1rem; }
    .rounded-3xl { border-radius: 1.5rem; }
    .rounded-full { border-radius: 9999px; }
    
    /* Shadows */
    .shadow { box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .shadow-lg { box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); }
    .shadow-xl { box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); }
    .shadow-mess { box-shadow: 0 10px 25px -5px rgba(34, 197, 94, 0.3); }
    
    /* Components */
    .card {
      background: var(--bg-card); border-radius: 1rem;
      border: 1px solid var(--border-light); box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    .glass {
      backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      background: rgba(255,255,255,0.8); border-bottom: 1px solid var(--border-light);
    }
    [data-theme="dark"] .glass {
      background: rgba(30,41,59,0.8);
    }
    
    .btn {
      display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
      padding: 0.75rem 1.5rem; border-radius: 0.75rem; font-weight: 500;
      cursor: pointer; transition: all 0.2s; border: none; font-size: 0.875rem;
    }
    .btn:active { transform: scale(0.98); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--mess-500), #10b981);
      color: white; box-shadow: 0 4px 14px rgba(34, 197, 94, 0.3);
    }
    .btn-primary:hover { box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4); }
    
    .btn-secondary {
      background: var(--bg-hover); color: var(--text);
    }
    .btn-secondary:hover { background: var(--border); }
    
    .btn-ghost {
      background: transparent; color: var(--text-secondary); padding: 0.5rem;
    }
    .btn-ghost:hover { background: var(--bg-hover); }
    
    .btn-sm { padding: 0.5rem 1rem; font-size: 0.875rem; }
    
    .input {
      width: 100%; padding: 0.75rem; border-radius: 0.75rem;
      border: 1px solid var(--border); background: var(--bg-card);
      color: var(--text); font-size: 0.875rem; transition: all 0.2s;
    }
    .input:focus {
      outline: none; border-color: var(--mess-500);
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.15);
    }
    .input::placeholder { color: var(--text-muted); }
    
    select.input { cursor: pointer; }
    textarea.input { resize: none; }
    
    .badge {
      display: inline-flex; align-items: center; padding: 0.25rem 0.625rem;
      border-radius: 9999px; font-size: 0.75rem; font-weight: 500;
    }
    
    .tab {
      padding: 0.75rem 1rem; font-weight: 500; font-size: 0.875rem;
      color: var(--text-muted); border-bottom: 2px solid transparent;
      cursor: pointer; transition: all 0.2s; white-space: nowrap;
    }
    .tab:hover { color: var(--text-secondary); }
    .tab.active { color: var(--mess-600); border-color: var(--mess-500); }
    [data-theme="dark"] .tab.active { color: var(--mess-400); }
    
    .thread-row {
      padding: 1rem; cursor: pointer; transition: background 0.2s;
      border-bottom: 1px solid var(--border-light);
    }
    .thread-row:hover { background: var(--bg-hover); }
    .thread-row:active { background: var(--border); }
    
    .icon-box {
      width: 2.5rem; height: 2.5rem; border-radius: 0.75rem;
      display: flex; align-items: center; justify-content: center;
      font-size: 1rem; flex-shrink: 0;
    }
    .icon-box-lg {
      width: 5rem; height: 5rem; border-radius: 1.5rem; font-size: 2.5rem;
    }
    
    .gradient-mesh {
      background: 
        radial-gradient(at 40% 20%, rgba(34, 197, 94, 0.12) 0px, transparent 50%),
        radial-gradient(at 80% 0%, rgba(6, 182, 212, 0.08) 0px, transparent 50%),
        radial-gradient(at 0% 50%, rgba(244, 63, 94, 0.06) 0px, transparent 50%),
        radial-gradient(at 80% 50%, rgba(139, 92, 246, 0.08) 0px, transparent 50%);
    }
    [data-theme="dark"] .gradient-mesh {
      background: 
        radial-gradient(at 40% 20%, rgba(34, 197, 94, 0.15) 0px, transparent 50%),
        radial-gradient(at 80% 0%, rgba(6, 182, 212, 0.1) 0px, transparent 50%),
        radial-gradient(at 0% 50%, rgba(244, 63, 94, 0.05) 0px, transparent 50%),
        radial-gradient(at 80% 50%, rgba(139, 92, 246, 0.12) 0px, transparent 50%);
    }
    
    .chip {
      display: inline-flex; align-items: center; gap: 0.25rem;
      padding: 0.375rem 0.625rem; border-radius: 0.5rem;
      font-size: 0.75rem; cursor: pointer; transition: all 0.2s;
      background: var(--bg-card); border: 1px solid var(--border);
    }
    .chip:hover { background: var(--bg-hover); }
    .chip.selected { background: var(--mess-100); border-color: var(--mess-300); color: var(--mess-700); }
    [data-theme="dark"] .chip.selected { background: rgba(34, 197, 94, 0.2); border-color: var(--mess-600); color: var(--mess-400); }
    
    .modal-backdrop {
      position: fixed; inset: 0; background: rgba(0,0,0,0.5);
      display: flex; align-items: center; justify-content: center;
      padding: 1rem; z-index: 50;
    }
    .modal { max-width: 28rem; width: 100%; max-height: 90vh; overflow-y: auto; }
    
    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
    
    /* Checkbox styling */
    input[type="checkbox"] {
      width: 1.25rem; height: 1.25rem; border-radius: 0.375rem;
      border: 1px solid var(--border); accent-color: var(--mess-500);
    }
    
    /* Utilities */
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0; }
    .sticky { position: sticky; top: 0; z-index: 10; }
    .relative { position: relative; }
    .cursor-pointer { cursor: pointer; }
    .select-none { user-select: none; }
    .max-h-48 { max-height: 12rem; }
    .max-h-32 { max-height: 8rem; }
  </style>
</head>
<body class="bg-page">
  <div id="app"></div>

  <script type="module">
    // ============ Theme Management ============
    function initTheme() {
      const stored = localStorage.getItem('mess-theme');
      if (stored === 'dark' || (!stored && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        document.documentElement.setAttribute('data-theme', 'dark');
      }
      updateThemeIcons();
    }
    
    function toggleTheme() {
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      document.documentElement.setAttribute('data-theme', isDark ? 'light' : 'dark');
      localStorage.setItem('mess-theme', isDark ? 'light' : 'dark');
      updateThemeIcons();
    }
    
    function updateThemeIcons() {
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      document.querySelectorAll('.theme-light').forEach(el => el.style.display = isDark ? 'none' : 'inline');
      document.querySelectorAll('.theme-dark').forEach(el => el.style.display = isDark ? 'inline' : 'none');
    }
    
    initTheme();

    // ============ Image Compression ============
    // Compress images to stay under GitHub's file size limits
    const IMAGE_MAX_DIMENSION = 1920; // Max width or height in pixels
    const IMAGE_QUALITY = 0.80;       // JPEG quality (0-1)
    const IMAGE_MAX_BYTES = 500000;   // Target max ~500KB base64

    // Expose for testing
    window.compressImage = compressImage;
    async function compressImage(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        img.onload = () => {
          // Calculate new dimensions, preserving aspect ratio
          let { width, height } = img;
          if (width > IMAGE_MAX_DIMENSION || height > IMAGE_MAX_DIMENSION) {
            if (width > height) {
              height = Math.round(height * IMAGE_MAX_DIMENSION / width);
              width = IMAGE_MAX_DIMENSION;
            } else {
              width = Math.round(width * IMAGE_MAX_DIMENSION / height);
              height = IMAGE_MAX_DIMENSION;
            }
          }

          canvas.width = width;
          canvas.height = height;
          ctx.drawImage(img, 0, 0, width, height);

          // Try progressively lower quality if still too large
          let quality = IMAGE_QUALITY;
          let dataUrl = canvas.toDataURL('image/jpeg', quality);

          while (dataUrl.length > IMAGE_MAX_BYTES && quality > 0.3) {
            quality -= 0.1;
            dataUrl = canvas.toDataURL('image/jpeg', quality);
          }

          console.log(`Image compressed: ${img.width}x${img.height} â†’ ${width}x${height}, quality=${quality.toFixed(1)}, size=${Math.round(dataUrl.length/1024)}KB`);
          resolve(dataUrl);
        };

        img.onerror = () => reject(new Error('Failed to load image'));

        // Load the file
        const reader = new FileReader();
        reader.onload = (e) => { img.src = e.target.result; };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(file);
      });
    }

    // ============ Capability Definitions ============
    // IDs use kebab-case per protocol recommendation
    const CAPABILITIES = {
      physical: {
        label: 'Physical Tasks',
        icon: 'ðŸƒ',
        color: 'orange',
        items: {
          'check-visual': { label: 'Visual checks', desc: 'Look at something, read a display' },
          'check-physical': { label: 'Physical inspection', desc: 'Touch, open, measure' },
          'fetch-indoor': { label: 'Fetch items (indoor)', desc: 'Get something from another room' },
          'fetch-outdoor': { label: 'Fetch items (outdoor)', desc: 'Pick up packages, check mailbox' },
          'operate-appliance': { label: 'Operate appliances', desc: 'Thermostat, washer, coffee maker' },
          'operate-vehicle': { label: 'Vehicle tasks', desc: 'Drive, check car status' },
        }
      },
      communication: {
        label: 'Communication',
        icon: 'ðŸ’¬',
        color: 'blue',
        items: {
          'make-phone-call': { label: 'Phone calls', desc: 'Make or receive calls' },
          'send-text-message': { label: 'Text messages', desc: 'Send SMS/texts' },
          'in-person-interaction': { label: 'In-person interaction', desc: 'Talk to delivery, neighbors' },
        }
      },
      information: {
        label: 'Information',
        icon: 'ðŸ“‹',
        color: 'purple',
        items: {
          'take-photo': { label: 'Take photos', desc: 'Capture and send images' },
          'read-document': { label: 'Read documents', desc: 'Physical mail, papers' },
          'local-research': { label: 'Local research', desc: 'Check store hours, availability' },
        }
      },
      care: {
        label: 'Care Tasks',
        icon: 'ðŸŒ±',
        color: 'green',
        items: {
          'plant-care': { label: 'Plant care', desc: 'Water, prune, check' },
          'pet-care': { label: 'Pet care', desc: 'Feed, walk, check on' },
          'child-supervision': { label: 'Child supervision', desc: 'Check on, assist' },
        }
      }
    };

    // Get all predefined capability IDs for filtering custom ones
    function getPredefinedCapabilities() {
      const ids = [];
      for (const cat of Object.values(CAPABILITIES)) {
        ids.push(...Object.keys(cat.items));
      }
      return ids;
    }

    // Parse custom capabilities from comma-separated string
    function parseCustomCapabilities(str) {
      if (!str) return [];
      return str.split(',')
        .map(s => s.trim().toLowerCase().replace(/[^a-z0-9-]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, ''))
        .filter(s => s.length > 0);
    }

    // Get custom capabilities from array (excludes predefined ones)
    function getCustomCapabilities(caps) {
      const predefined = getPredefinedCapabilities();
      return (caps || []).filter(c => !predefined.includes(c));
    }

    // ============ Size Limits (v2 format) ============
    const MAX_FILE_SIZE = 1024 * 1024;        // 1 MB - GitHub Contents API limit
    const MAX_INLINE_SIZE = 768 * 1024;       // 768 KB - inline attachment limit

    // ============ Attachment Helpers ============
    function getAttachmentType(mimeType) {
      if (mimeType?.startsWith('image/')) return 'image';
      if (mimeType?.startsWith('audio/')) return 'audio';
      if (mimeType?.startsWith('video/')) return 'video';
      return 'file';
    }

    function sanitizeFilename(name) {
      return name.replace(/[^a-zA-Z0-9._-]/g, '_').replace(/_+/g, '_');
    }

    function getExtensionFromMime(mimeType) {
      const mimeToExt = {
        'image/jpeg': 'jpg', 'image/png': 'png', 'image/gif': 'gif', 'image/webp': 'webp',
        'audio/mpeg': 'mp3', 'audio/wav': 'wav', 'audio/mp4': 'm4a', 'audio/webm': 'webm',
        'video/mp4': 'mp4', 'video/quicktime': 'mov', 'video/webm': 'webm',
        'application/pdf': 'pdf', 'text/plain': 'txt'
      };
      return mimeToExt[mimeType] || 'bin';
    }

    // ============ GitHub API Client ============
    class GitHubExchange {
      constructor(owner, repo, token) {
        this.owner = owner;
        this.repo = repo;
        this.token = token;
        this.baseUrl = `https://api.github.com/repos/${owner}/${repo}`;
        this._cachedTree = null;  // Cache for tree discovery
        this._cachedTreeExpires = 0;
      }

      // Invalidate tree cache (call after mutations)
      invalidateTreeCache() {
        this._cachedTree = null;
        this._cachedTreeExpires = 0;
      }

      // Get the full repository tree (cached for 30 seconds)
      async getFullTree() {
        const now = Date.now();
        if (this._cachedTree && this._cachedTreeExpires > now) {
          return this._cachedTree;
        }

        const refData = await this.request('/git/ref/heads/main');
        const commitData = await this.request(`/git/commits/${refData.object.sha}`);
        const tree = await this.request(`/git/trees/${commitData.tree.sha}?recursive=1`);

        this._cachedTree = tree;
        this._cachedTreeExpires = now + 30000;  // Cache for 30 seconds
        return tree;
      }

      // Discover all threads from the tree in one API call
      // Returns: { received: [{ref, path, files: [{name, path, sha}]}], executing: [...], ... }
      async discoverThreads() {
        const tree = await this.getFullTree();
        const folders = ['received', 'executing', 'finished', 'canceled'];
        const discovery = { received: [], executing: [], finished: [], canceled: [] };

        // Group files by thread
        const threadMap = new Map();  // path -> { folder, ref, format, files: [] }

        for (const item of tree.tree) {
          if (item.type !== 'blob') continue;
          if (!item.path.startsWith('exchange/state=')) continue;
          if (!item.path.includes('.messe-af.yaml')) continue;

          // Parse path: exchange/state={folder}/{ref}.messe-af.yaml (v1)
          //         or: exchange/state={folder}/{ref}/{filename}.messe-af.yaml (v2)
          const match = item.path.match(/^exchange\/state=(\w+)\/([^/]+)(\/(.+))?$/);
          if (!match) continue;

          const [, folder, firstPart, , filename] = match;
          if (!folders.includes(folder)) continue;

          let threadRef, threadPath, format;
          if (filename) {
            // V2 format: firstPart is the directory name (ref), filename is the file
            threadRef = firstPart;
            threadPath = `exchange/state=${folder}/${threadRef}`;
            format = 'v2';
          } else {
            // V1 format: firstPart is the full filename
            threadRef = firstPart.replace('.messe-af.yaml', '');
            threadPath = `exchange/state=${folder}/${firstPart}`;
            format = 'v1';
          }

          const key = `${folder}:${threadRef}`;
          if (!threadMap.has(key)) {
            threadMap.set(key, { folder, ref: threadRef, path: threadPath, format, files: [] });
          }
          threadMap.get(key).files.push({ name: filename || firstPart, path: item.path, sha: item.sha });
        }

        // Group by folder
        for (const thread of threadMap.values()) {
          discovery[thread.folder].push(thread);
        }

        return discovery;
      }

      async request(path, options = {}) {
        const res = await fetch(`${this.baseUrl}${path}`, {
          ...options,
          headers: {
            'Authorization': `Bearer ${this.token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json',
            ...options.headers
          }
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.message || `GitHub API error: ${res.status}`);
        }
        return res.json();
      }

      async testConnection() {
        const res = await fetch(`${this.baseUrl}`, {
          headers: {
            'Authorization': `Bearer ${this.token}`,
            'Accept': 'application/vnd.github.v3+json',
          }
        });
        if (!res.ok) {
          if (res.status === 401) throw new Error('Invalid token');
          if (res.status === 404) throw new Error('Repository not found (check name or token permissions)');
          throw new Error(`Connection failed: ${res.status}`);
        }
        const data = await res.json();
        return { name: data.full_name, private: data.private, permissions: data.permissions };
      }

      async listFolder(folder) {
        try {
          const data = await this.request(`/contents/exchange/state=${folder}`);
          // Return both v1 yaml files and v2 directories
          return data.filter(f => f.name.endsWith('.messe-af.yaml') || f.type === 'dir');
        } catch (e) {
          if (e.message.includes('404')) return [];
          throw e;
        }
      }

      async getFile(path) {
        const data = await this.request(`/contents/${path}`);
        const content = atob(data.content.replace(/\n/g, ''));
        return { content, sha: data.sha };
      }

      // Batch fetch multiple files using GitHub GraphQL API
      // Returns: Map<path, {content, sha}>
      async getFilesBatch(paths) {
        if (paths.length === 0) return new Map();

        // Build GraphQL query with aliased file fetches
        const fileQueries = paths.map((path, i) =>
          `f${i}: object(expression: "main:${path}") { ... on Blob { text oid } }`
        ).join('\n      ');

        const query = `query {
    repository(owner: "${this.owner}", name: "${this.repo}") {
      ${fileQueries}
    }
  }`;

        try {
          const response = await fetch('https://api.github.com/graphql', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${this.token}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ query })
          });

          if (!response.ok) {
            throw new Error(`GraphQL error: ${response.status}`);
          }

          const data = await response.json();
          if (data.errors) {
            console.warn('[GitHub] GraphQL errors:', data.errors);
          }

          const results = new Map();
          const repo = data.data?.repository;
          if (repo) {
            paths.forEach((path, i) => {
              const file = repo[`f${i}`];
              if (file && file.text !== null) {
                results.set(path, { content: file.text, sha: file.oid });
              }
            });
          }
          return results;
        } catch (e) {
          console.error('[GitHub] GraphQL batch fetch failed:', e);
          // Fall back to individual fetches
          const results = new Map();
          for (const path of paths) {
            try {
              const file = await this.getFile(path);
              results.set(path, file);
            } catch (err) {
              console.error(`Failed to fetch ${path}:`, err);
            }
          }
          return results;
        }
      }

      async putFile(path, content, message, sha = null) {
        const body = { message, content: btoa(unescape(encodeURIComponent(content))) };
        if (sha) body.sha = sha;
        return await this.request(`/contents/${path}`, { method: 'PUT', body: JSON.stringify(body) });
      }

      async deleteFile(path, sha, message) {
        return await this.request(`/contents/${path}`, { method: 'DELETE', body: JSON.stringify({ message, sha }) });
      }

      // Get directory contents (v2 format) - uses Contents API
      async getDirectory(dirPath) {
        try {
          const data = await this.request(`/contents/${dirPath}`);
          if (!Array.isArray(data)) return null;
          return data;
        } catch (e) {
          if (e.message.includes('404')) return null;
          throw e;
        }
      }

      // Get files in a directory from a specific git tree (more reliable than Contents API)
      async getFilesFromTree(treeSha, dirPath) {
        console.log('[GitHub] getFilesFromTree called:', { treeSha, dirPath });
        try {
          // Get the full tree recursively
          const tree = await this.request(`/git/trees/${treeSha}?recursive=1`);
          console.log('[GitHub] Tree API returned:', tree.tree?.length || 0, 'entries, truncated:', tree.truncated);

          // Filter to files in the specified directory
          const prefix = dirPath + '/';
          const files = tree.tree.filter(item =>
            item.type === 'blob' && item.path.startsWith(prefix)
          );

          // Debug: show what we found
          if (files.length === 0) {
            const exchangePaths = tree.tree.filter(t => t.path.startsWith('exchange/')).map(t => t.path);
            console.log('[GitHub] Looking for prefix:', prefix);
            console.log('[GitHub] Exchange paths in tree:', exchangePaths);
          } else {
            console.log('[GitHub] Found', files.length, 'files for prefix:', prefix);
          }
          return files.map(f => ({ name: f.path.substring(prefix.length), path: f.path, sha: f.sha }));
        } catch (e) {
          console.error('[GitHub] getFilesFromTree error:', e);
          return [];
        }
      }

      // Create directory with files using Git Data API (atomic)
      async createDirectory(dirPath, files, message) {
        const refData = await this.request('/git/ref/heads/main');
        const currentCommitSha = refData.object.sha;
        const commitData = await this.request(`/git/commits/${currentCommitSha}`);
        const baseTreeSha = commitData.tree.sha;

        const treeEntries = files.map(f => ({
          path: `${dirPath}/${f.name}`,
          mode: '100644',
          type: 'blob',
          content: f.binary ? atob(f.content) : f.content
        }));

        const treeData = await this.request('/git/trees', {
          method: 'POST',
          body: JSON.stringify({ base_tree: baseTreeSha, tree: treeEntries })
        });

        const newCommit = await this.request('/git/commits', {
          method: 'POST',
          body: JSON.stringify({ message, tree: treeData.sha, parents: [currentCommitSha] })
        });

        await this.request('/git/refs/heads/main', {
          method: 'PATCH',
          body: JSON.stringify({ sha: newCommit.sha })
        });

        // Invalidate tree cache after mutation
        this.invalidateTreeCache();

        return newCommit;
      }

      // Update files in a directory atomically
      async updateDirectoryFiles(dirPath, updates, message, retries = 3) {
        for (let attempt = 1; attempt <= retries; attempt++) {
          try {
            const refData = await this.request('/git/ref/heads/main');
            const currentCommitSha = refData.object.sha;
            const commitData = await this.request(`/git/commits/${currentCommitSha}`);
            const baseTreeSha = commitData.tree.sha;

            const treeEntries = updates.map(u => ({
              path: `${dirPath}/${u.name}`,
              mode: '100644',
              type: 'blob',
              ...(u.sha === null ? { sha: null } : { content: u.binary ? atob(u.content) : u.content })
            }));

            const treeData = await this.request('/git/trees', {
              method: 'POST',
              body: JSON.stringify({ base_tree: baseTreeSha, tree: treeEntries })
            });

            const newCommit = await this.request('/git/commits', {
              method: 'POST',
              body: JSON.stringify({ message, tree: treeData.sha, parents: [currentCommitSha] })
            });

            await this.request('/git/refs/heads/main', {
              method: 'PATCH',
              body: JSON.stringify({ sha: newCommit.sha })
            });

            this.invalidateTreeCache();
            return newCommit;
          } catch (e) {
            const isConflict = e.message.includes('fast forward') || e.message.includes('422');
            if (isConflict && attempt < retries) {
              await new Promise(r => setTimeout(r, 500 * attempt));
              continue;
            }
            throw e;
          }
        }
      }

      // Move directory atomically using Git Data API
      async moveDirectory(oldDirPath, newDirPath, message, retries = 3) {
        for (let attempt = 1; attempt <= retries; attempt++) {
          try {
            const refData = await this.request('/git/ref/heads/main');
            const currentCommitSha = refData.object.sha;
            const commitData = await this.request(`/git/commits/${currentCommitSha}`);
            const baseTreeSha = commitData.tree.sha;

            const oldFiles = await this.getDirectory(oldDirPath);
            if (!oldFiles) throw new Error(`Directory not found: ${oldDirPath}`);

            const treeEntries = [];
            for (const file of oldFiles) {
              // Delete from old location
              treeEntries.push({
                path: `${oldDirPath}/${file.name}`,
                mode: '100644',
                type: 'blob',
                sha: null
              });
              // Get content and create at new location
              const fileContent = await this.getFile(`${oldDirPath}/${file.name}`);
              if (fileContent) {
                treeEntries.push({
                  path: `${newDirPath}/${file.name}`,
                  mode: '100644',
                  type: 'blob',
                  content: fileContent.content
                });
              }
            }

            const treeData = await this.request('/git/trees', {
              method: 'POST',
              body: JSON.stringify({ base_tree: baseTreeSha, tree: treeEntries })
            });

            const newCommit = await this.request('/git/commits', {
              method: 'POST',
              body: JSON.stringify({ message, tree: treeData.sha, parents: [currentCommitSha] })
            });

            await this.request('/git/refs/heads/main', {
              method: 'PATCH',
              body: JSON.stringify({ sha: newCommit.sha })
            });

            this.invalidateTreeCache();
            return newCommit;
          } catch (e) {
            const isConflict = e.message.includes('fast forward') || e.message.includes('422');
            if (isConflict && attempt < retries) {
              await new Promise(r => setTimeout(r, 500 * attempt));
              continue;
            }
            throw e;
          }
        }
      }

      // Atomic move: delete old path + create new path in single commit
      // Retries on "not a fast forward" conflicts
      async moveFile(oldPath, newPath, content, message, retries = 3) {
        for (let attempt = 1; attempt <= retries; attempt++) {
          try {
            // Get current main branch ref
            const refData = await this.request('/git/ref/heads/main');
            const currentCommitSha = refData.object.sha;

            // Get current commit's tree
            const commitData = await this.request(`/git/commits/${currentCommitSha}`);
            const baseTreeSha = commitData.tree.sha;

            // Create new tree with deletion + addition in one operation
            const treeData = await this.request('/git/trees', {
              method: 'POST',
              body: JSON.stringify({
                base_tree: baseTreeSha,
                tree: [
                  { path: oldPath, mode: '100644', type: 'blob', sha: null }, // delete
                  { path: newPath, mode: '100644', type: 'blob', content }    // create
                ]
              })
            });

            // Create commit
            const newCommit = await this.request('/git/commits', {
              method: 'POST',
              body: JSON.stringify({
                message,
                tree: treeData.sha,
                parents: [currentCommitSha]
              })
            });

            // Update ref - this is where conflicts are detected
            await this.request('/git/refs/heads/main', {
              method: 'PATCH',
              body: JSON.stringify({ sha: newCommit.sha })
            });

            this.invalidateTreeCache();
            return newCommit;
          } catch (e) {
            const isConflict = e.message.includes('fast forward') || e.message.includes('422');
            if (isConflict && attempt < retries) {
              // Wait briefly then retry with fresh ref
              await new Promise(r => setTimeout(r, 500 * attempt));
              continue;
            }
            throw e;
          }
        }
      }

      // Parse thread from v2 directory format
      parseThread(files) {
        const yamlFiles = files
          .filter(f => f.name.endsWith('.messe-af.yaml'))
          .sort((a, b) => {
            const numA = parseInt(a.name.split('-')[0]);
            const numB = parseInt(b.name.split('-')[0]);
            return numA - numB;
          });

        if (yamlFiles.length === 0) throw new Error('No YAML files in thread directory');

        const firstDocs = yamlFiles[0].content.split(/^---$/m).filter(d => d.trim()).map(d => jsyaml.load(d));
        const envelope = firstDocs[0];
        const messages = firstDocs.slice(1);

        for (let i = 1; i < yamlFiles.length; i++) {
          const docs = yamlFiles[i].content.split(/^---$/m).filter(d => d.trim()).map(d => jsyaml.load(d));
          messages.push(...docs);
        }

        const attachments = files.filter(f => f.name.startsWith('att-')).map(f => ({ name: f.name, sha: f.sha }));
        return { envelope, messages, attachments };
      }

      // Parse thread from v1 flat file format
      parseThreadV1(content) {
        const docs = content.split(/^---$/m).filter(d => d.trim()).map(d => jsyaml.load(d));
        return { envelope: docs[0], messages: docs.slice(1), attachments: [] };
      }

      // Get thread - handles both v1 and v2 formats
      async getThread(folder, entryName) {
        const isDirectory = !entryName.endsWith('.messe-af.yaml');

        if (isDirectory) {
          // V2 directory format
          const dirPath = `exchange/state=${folder}/${entryName}`;
          const dirContents = await this.getDirectory(dirPath);
          if (!dirContents) throw new Error('Directory not found');

          const files = [];
          for (const entry of dirContents) {
            if (entry.type === 'file') {
              const fileData = await this.getFile(`${dirPath}/${entry.name}`);
              if (fileData) {
                files.push({ name: entry.name, content: fileData.content, sha: fileData.sha });
              }
            }
          }

          const parsed = this.parseThread(files);
          return {
            ...parsed,
            _path: dirPath,
            _files: files,
            _format: 'v2'
          };
        } else {
          // V1 flat file format
          const path = `exchange/state=${folder}/${entryName}`;
          const { content, sha } = await this.getFile(path);
          const parsed = this.parseThreadV1(content);
          return {
            ...parsed,
            _path: path,
            _sha: sha,
            _format: 'v1'
          };
        }
      }

      // Load a single thread from discovered file info
      async loadThreadFromDiscovery(threadInfo) {
        const { ref, path, format, files } = threadInfo;

        if (format === 'v2') {
          // Fetch all files in parallel
          const fileContents = await Promise.all(
            files.map(async (f) => {
              try {
                const { content, sha } = await this.getFile(f.path);
                return { name: f.name, content, sha };
              } catch (e) {
                console.error(`Failed to load file ${f.path}:`, e);
                return null;
              }
            })
          );

          const validFiles = fileContents.filter(f => f !== null);
          const parsed = this.parseThread(validFiles);
          return {
            ...parsed,
            _path: path,
            _files: validFiles,
            _format: 'v2'
          };
        } else {
          // V1 format - single file
          const file = files[0];
          const { content, sha } = await this.getFile(file.path);
          const parsed = this.parseThreadV1(content);
          return {
            ...parsed,
            _path: path,
            _sha: sha,
            _format: 'v1'
          };
        }
      }

      // Load threads for a single folder using tree discovery and batch GraphQL fetching
      async listThreadsForFolder(folder, discovery = null) {
        // Use provided discovery or fetch it
        if (!discovery) {
          discovery = await this.discoverThreads();
        }

        const threadInfos = discovery[folder] || [];
        if (threadInfos.length === 0) return [];

        // Collect all file paths to batch fetch
        const allPaths = [];
        const pathToThread = new Map();  // Map path -> {threadIndex, fileIndex}

        threadInfos.forEach((info, threadIndex) => {
          info.files.forEach((file, fileIndex) => {
            // Only fetch .yaml files via GraphQL (text content)
            if (file.path.endsWith('.messe-af.yaml')) {
              allPaths.push(file.path);
              pathToThread.set(file.path, { threadIndex, fileIndex, info });
            }
          });
        });

        // Batch fetch all files using GraphQL
        const fileContents = await this.getFilesBatch(allPaths);

        // Build threads from the fetched content
        const threads = [];
        for (const info of threadInfos) {
          try {
            const { ref, path, format, files } = info;

            if (format === 'v2') {
              const validFiles = [];
              for (const file of files) {
                const content = fileContents.get(file.path);
                if (content) {
                  validFiles.push({ name: file.name, content: content.content, sha: content.sha });
                }
              }

              if (validFiles.length === 0) {
                console.error(`No valid files found for thread ${ref}`);
                continue;
              }

              const parsed = this.parseThread(validFiles);
              threads.push({
                ...parsed.envelope,
                envelope: parsed.envelope,
                messages: parsed.messages,
                attachments: parsed.attachments,
                _path: path,
                _files: validFiles,
                _format: 'v2'
              });
            } else {
              // V1 format - single file
              const file = files[0];
              const content = fileContents.get(file.path);
              if (!content) {
                console.error(`Failed to fetch v1 thread ${ref}`);
                continue;
              }

              const parsed = this.parseThreadV1(content.content);
              threads.push({
                ...parsed.envelope,
                envelope: parsed.envelope,
                messages: parsed.messages,
                attachments: parsed.attachments,
                _path: path,
                _sha: content.sha,
                _format: 'v1'
              });
            }
          } catch (e) {
            console.error(`Failed to parse ${info.ref}:`, e);
          }
        }

        threads.sort((a, b) => new Date(b.updated) - new Date(a.updated));
        return threads;
      }

      async listThreads() {
        // Get discovery once for all folders
        const discovery = await this.discoverThreads();
        const folders = ['received', 'executing', 'finished', 'canceled'];
        const results = { received: [], executing: [], finished: [], canceled: [] };

        for (const folder of folders) {
          results[folder] = await this.listThreadsForFolder(folder, discovery);
        }

        return results;
      }

      // Serialize thread - returns array of files for v2 directory format
      serializeThread(envelope, messages, attachments = []) {
        const files = [];

        // Calculate next attachment serial
        let nextSerial = 1;
        for (const att of attachments) {
          const match = att.name.match(/^att-(\d+)-/);
          if (match) {
            const serial = parseInt(match[1]);
            if (serial >= nextSerial) nextSerial = serial + 1;
          }
        }

        // Start with envelope in file 000
        let currentFileNum = 0;
        let currentDocs = [envelope];
        let currentSize = new Blob([jsyaml.dump(envelope, { lineWidth: -1 })]).size;

        for (const msg of messages) {
          // Process attachments in message
          const processed = this.processMessageAttachments(msg, attachments, nextSerial);
          if (processed.newAttachments) {
            for (const att of processed.newAttachments) {
              attachments.push(att);
              nextSerial++;
            }
          }

          const msgYaml = jsyaml.dump(processed.message, { lineWidth: -1 });
          const msgSize = new Blob([msgYaml]).size;

          // Would adding this message exceed the limit?
          if (currentSize + msgSize + 4 > MAX_FILE_SIZE && currentDocs.length > 1) {
            files.push({
              name: `${currentFileNum.toString().padStart(3, '0')}-${envelope.ref}.messe-af.yaml`,
              content: currentDocs.map(d => jsyaml.dump(d, { lineWidth: -1 })).join('---\n')
            });
            currentFileNum++;
            currentDocs = [];
            currentSize = 0;
          }

          currentDocs.push(processed.message);
          currentSize += msgSize + 4;
        }

        // Save final file
        if (currentDocs.length > 0) {
          files.push({
            name: `${currentFileNum.toString().padStart(3, '0')}-${envelope.ref}.messe-af.yaml`,
            content: currentDocs.map(d => jsyaml.dump(d, { lineWidth: -1 })).join('---\n')
          });
        }

        // Add attachment files
        for (const att of attachments) {
          if (att.content) {
            files.push({ name: att.name, content: att.content, binary: att.binary });
          }
        }

        return files;
      }

      // Process message to externalize large attachments
      processMessageAttachments(msg, existingAttachments, startSerial) {
        const newAttachments = [];
        let serial = startSerial;
        const processedMsg = JSON.parse(JSON.stringify(msg));

        if (processedMsg.MESS) {
          for (const item of processedMsg.MESS) {
            if (item.response?.content) {
              item.response.content = item.response.content.map(c => {
                if (typeof c === 'object' && c.image) {
                  const dataUrl = c.image;
                  const size = new Blob([dataUrl]).size;

                  if (size > MAX_INLINE_SIZE) {
                    const match = dataUrl.match(/^data:([^;]+);base64,(.+)$/);
                    if (match) {
                      const [, mime, base64Data] = match;
                      const type = getAttachmentType(mime);
                      const ext = getExtensionFromMime(mime);
                      const attName = `att-${serial.toString().padStart(3, '0')}-${type}-image.${ext}`;

                      newAttachments.push({ name: attName, content: base64Data, binary: true });
                      serial++;

                      return { file: { path: attName, name: `image.${ext}`, mime } };
                    }
                  }
                }
                return c;
              });
            }
          }
        }

        return { message: processedMsg, newAttachments };
      }

      async createRequest(from, request) {
        const today = new Date().toISOString().split('T')[0];
        const existing = await this.listFolder('received');
        const todayEntries = existing.filter(e => e.name.startsWith(today));
        const ref = `${today}-${(todayEntries.length + 1).toString().padStart(3, '0')}`;

        const now = new Date().toISOString();
        const envelope = {
          ref, requestor: from, executor: null, status: 'pending',
          created: now, updated: now, intent: request.intent,
          priority: request.priority || 'normal',
          history: [{ action: 'created', at: now, by: from }]
        };

        const messages = [
          { from, received: now, channel: 'github', MESS: [{ v: '1.0.0' }, { request }] },
          { from: 'exchange', received: now, MESS: [{ ack: { re: 'last', ref } }] }
        ];

        // V2: Create directory with files
        const files = this.serializeThread(envelope, messages);
        const dirPath = `exchange/state=received/${ref}`;
        await this.createDirectory(dirPath, files, `${ref}: New request`);

        return { ref, status: 'pending' };
      }

      async updateThread(thread, from, mess, newStatus = null, retries = 3) {
        const now = new Date().toISOString();
        const envelope = { ...thread.envelope };
        const messages = [...thread.messages, { from, received: now, channel: 'github', MESS: mess }];
        const attachments = [...(thread.attachments || [])];

        const oldFolder = this.getFolder(envelope.status);
        if (newStatus && newStatus !== envelope.status) {
          envelope.status = newStatus;
          envelope.updated = now;
          if (!envelope.history) envelope.history = [];
          envelope.history.push({ action: newStatus, at: now, by: from });
          if (newStatus === 'claimed') envelope.executor = from;
        }

        const newFolder = this.getFolder(envelope.status);
        const files = this.serializeThread(envelope, messages, attachments);
        const needsMove = newFolder !== oldFolder;
        const newDirPath = `exchange/state=${newFolder}/${envelope.ref}`;
        const commitMessage = `${envelope.ref}: ${newStatus || 'Update'}${thread._format === 'v1' ? ' (upgraded to v2)' : ''}`;

        // All updates now use a single atomic commit with retry logic
        for (let attempt = 1; attempt <= retries; attempt++) {
          try {
            const refData = await this.request('/git/ref/heads/main');
            const currentCommitSha = refData.object.sha;
            const commitData = await this.request(`/git/commits/${currentCommitSha}`);
            const baseTreeSha = commitData.tree.sha;

            const treeEntries = [];

            // Calculate old directory path for v2 format (from oldFolder, not thread._path which may be stale)
            const oldDirPath = `exchange/state=${oldFolder}/${envelope.ref}`;

            // Handle v1 format - delete old file
            if (thread._format === 'v1') {
              treeEntries.push({ path: thread._path, mode: '100644', type: 'blob', sha: null });
            }
            // Handle v2 format with move - delete old files
            // Use getFilesFromTree to get files from the actual base tree (not Contents API which can be stale)
            else if (needsMove) {
              const oldFiles = await this.getFilesFromTree(baseTreeSha, oldDirPath);
              console.log('[GitHub] getFilesFromTree for move:', oldDirPath, `${oldFiles.length} files`);
              if (oldFiles.length > 0) {
                for (const file of oldFiles) {
                  treeEntries.push({
                    path: file.path,
                    mode: '100644',
                    type: 'blob',
                    sha: null
                  });
                }
              } else {
                console.warn('[GitHub] WARNING: No files found in tree for path:', oldDirPath);
              }
            }

            // Add new/updated files at destination
            const destPath = (thread._format === 'v1' || needsMove) ? newDirPath : thread._path;
            for (const f of files) {
              treeEntries.push({
                path: `${destPath}/${f.name}`,
                mode: '100644',
                type: 'blob',
                content: f.binary ? atob(f.content) : f.content
              });
            }

            // Debug logging for tree operations
            console.log('[GitHub] updateThread:', {
              format: thread._format,
              needsMove,
              oldDirPath,
              destPath,
              deletes: treeEntries.filter(e => e.sha === null).map(e => e.path),
              creates: treeEntries.filter(e => e.content).map(e => e.path)
            });

            const treeData = await this.request('/git/trees', {
              method: 'POST',
              body: JSON.stringify({ base_tree: baseTreeSha, tree: treeEntries })
            });

            const newCommit = await this.request('/git/commits', {
              method: 'POST',
              body: JSON.stringify({
                message: commitMessage,
                tree: treeData.sha,
                parents: [currentCommitSha]
              })
            });

            await this.request('/git/refs/heads/main', {
              method: 'PATCH',
              body: JSON.stringify({ sha: newCommit.sha })
            });

            this.invalidateTreeCache();
            return envelope;
          } catch (e) {
            // Retry on conflicts: fast-forward errors, 422 status, or BadObjectState (stale tree)
            const isConflict = e.message.includes('fast forward') ||
                               e.message.includes('422') ||
                               e.message.includes('BadObjectState');
            if (isConflict && attempt < retries) {
              console.log(`[GitHub] Retry ${attempt}/${retries} after conflict: ${e.message}`);
              await new Promise(r => setTimeout(r, 500 * attempt));
              continue;
            }
            throw e;
          }
        }
      }

      getFolder(status) {
        const map = {
          pending: 'received', claimed: 'executing', in_progress: 'executing',
          waiting: 'executing', held: 'executing', needs_input: 'executing',
          completed: 'finished', partial: 'finished',
          failed: 'canceled', declined: 'canceled', cancelled: 'canceled', expired: 'canceled'
        };
        return map[status] || 'received';
      }

      async registerExecutor(config) {
        const path = `executors/${config.executor_id}.yaml`;
        const content = jsyaml.dump(config, { lineWidth: -1 });
        try {
          const existing = await this.getFile(path);
          await this.putFile(path, content, `Update executor: ${config.executor_id}`, existing.sha);
        } catch (e) {
          await this.putFile(path, content, `Register executor: ${config.executor_id}`);
        }
      }

      // Fetch exchange-defined capabilities from capabilities/ directory
      async getExchangeCapabilities() {
        try {
          const tree = await this.getFullTree();
          const capFiles = tree.tree.filter(t =>
            t.path.startsWith('capabilities/') && t.path.endsWith('.yaml') && t.type === 'blob'
          );

          if (capFiles.length === 0) return [];

          const paths = capFiles.map(f => f.path);
          const contents = await this.getFilesBatch(paths);

          const capabilities = [];
          for (const path of paths) {
            const content = contents[path];
            if (!content) continue;

            // Parse multi-doc YAML (capabilities separated by ---)
            const docs = content.split(/^---$/m).filter(d => d.trim());
            for (const doc of docs) {
              try {
                const cap = jsyaml.load(doc);
                if (cap && cap.id) {
                  capabilities.push({
                    id: cap.id,
                    description: cap.description || '',
                    tags: cap.tags || []
                  });
                }
              } catch (e) { /* skip invalid docs */ }
            }
          }
          return capabilities;
        } catch (e) {
          console.log('Could not load exchange capabilities:', e.message);
          return [];
        }
      }
    }

    // ============ Local API Exchange Client ============
    // Used when served from the PHP server (or any local REST API server)
    class LocalApiExchange {
      constructor(baseUrl, token, exchangeId) {
        this.baseUrl = baseUrl.replace(/\/$/, '');  // Remove trailing slash
        this.token = token;
        this.exchangeId = exchangeId;
      }

      invalidateTreeCache() {
        // No caching in local API mode
      }

      async request(path, options = {}) {
        const res = await fetch(`${this.baseUrl}${path}`, {
          ...options,
          headers: {
            'Authorization': `Bearer ${this.token}`,
            'Content-Type': 'application/json',
            ...options.headers
          }
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.error || `API error: ${res.status}`);
        }
        return res.json();
      }

      async testConnection() {
        const res = await fetch(`${this.baseUrl}/health`);
        if (!res.ok) throw new Error('Server not available');
        const data = await res.json();
        return { name: `${data.service} (${data.exchange_id})`, private: true, permissions: { push: true } };
      }

      async listThreads() {
        const data = await this.request(`/api/v1/exchanges/${this.exchangeId}/requests`);
        const threads = data.threads || [];

        // Group by folder
        const results = { received: [], executing: [], finished: [], canceled: [] };
        for (const t of threads) {
          const folder = this.getFolder(t.status);
          // Build thread object compatible with GitHubExchange format
          const thread = {
            ref: t.ref,
            requestor: t.requestor_id,
            executor: t.executor_id,
            status: t.status,
            created: t.created_at,
            updated: t.updated_at,
            intent: t.intent,
            priority: t.priority,
            envelope: {
              ref: t.ref,
              requestor: t.requestor_id,
              executor: t.executor_id,
              status: t.status,
              created: t.created_at,
              updated: t.updated_at,
              intent: t.intent,
              priority: t.priority,
            },
            messages: [],  // Will be loaded on demand
            attachments: [],
            _format: 'api'
          };
          results[folder].push(thread);
        }

        // Sort by updated time (newest first)
        for (const folder of Object.keys(results)) {
          results[folder].sort((a, b) => new Date(b.updated) - new Date(a.updated));
        }

        return results;
      }

      async getThread(ref) {
        const data = await this.request(`/api/v1/exchanges/${this.exchangeId}/requests/${ref}`);
        const t = data.thread;
        return {
          ref: t.ref,
          requestor: t.requestor_id,
          executor: t.executor_id,
          status: t.status,
          created: t.created_at,
          updated: t.updated_at,
          intent: t.intent,
          priority: t.priority,
          envelope: {
            ref: t.ref,
            requestor: t.requestor_id,
            executor: t.executor_id,
            status: t.status,
            created: t.created_at,
            updated: t.updated_at,
            intent: t.intent,
            priority: t.priority,
          },
          messages: (t.messages || []).map(m => ({
            from: m.from,
            received: m.ts,
            MESS: m.mess
          })),
          attachments: [],
          _format: 'api'
        };
      }

      async createRequest(from, request) {
        const data = await this.request(`/api/v1/exchanges/${this.exchangeId}/requests`, {
          method: 'POST',
          body: JSON.stringify({
            intent: request.intent,
            context: request.context,
            priority: request.priority,
            response_hints: request.response_hint
          })
        });
        return { ref: data.ref, status: data.status };
      }

      async updateThread(thread, from, mess, newStatus = null) {
        const body = {};
        if (newStatus) body.status = newStatus;
        if (mess) body.mess = mess;

        const data = await this.request(`/api/v1/exchanges/${this.exchangeId}/requests/${thread.ref}`, {
          method: 'PATCH',
          body: JSON.stringify(body)
        });

        // Return updated envelope
        return {
          ...thread.envelope,
          status: data.status,
          updated: new Date().toISOString()
        };
      }

      getFolder(status) {
        const map = {
          pending: 'received', claimed: 'executing', 'in-progress': 'executing',
          waiting: 'executing', held: 'executing', needs_input: 'executing',
          completed: 'finished', partial: 'finished',
          failed: 'canceled', declined: 'canceled', cancelled: 'canceled', expired: 'canceled'
        };
        return map[status] || 'received';
      }

      async registerExecutor(config) {
        await this.request(`/api/v1/exchanges/${this.exchangeId}/executors/${config.executor_id}`, {
          method: 'PATCH',
          body: JSON.stringify({
            display_name: config.display_name,
            capabilities: config.capabilities
          })
        });
      }

      async getExchangeCapabilities() {
        // TODO: Implement capabilities endpoint
        return [];
      }
    }

    // ============ API Mode Detection ============
    function isLocalApiMode() {
      // Detect if we're being served from a local server (not GitHub Pages)
      const hostname = window.location.hostname;
      const isGitHubPages = hostname.endsWith('.github.io');
      const isLocalhost = hostname === 'localhost' || hostname === '127.0.0.1' || hostname.startsWith('192.168.');
      const hasLocalConfig = localStorage.getItem('mess-local-mode') === 'true';

      return !isGitHubPages && (isLocalhost || hasLocalConfig);
    }

    function getApiBaseUrl() {
      // When in local mode, API is on the same origin
      return window.location.origin;
    }

    // ============ App State ============
    const state = {
      config: JSON.parse(localStorage.getItem('mess-executor-config') || 'null'),
      github: null,
      isLocalMode: isLocalApiMode(),
      threads: { received: [], executing: [], finished: [], canceled: [] },
      currentFolder: 'received',
      selectedThread: null,
      loading: false,
      error: null,
      view: 'loading',
      setupStep: 1,
      connectionTest: null,
      showNewRequest: false,
      // Exchange-defined capabilities from capabilities/ directory (loaded on demand)
      exchangeCapabilities: [],
      // Thread filters (all off by default - user can enable as needed)
      filters: {
        capableOnly: false,      // Show only threads matching my capabilities
        myClaimsOnly: false,     // Show only threads I've claimed (executing tab)
        awaitingAnswer: false,   // Show threads with needs_input status (awaiting requestor answer)
        hasNewAnswer: false,     // Show threads that have a reply after needs_input
      },
      // Lightbox state for viewing images
      lightboxImage: null,
      // Periodic sync
      syncInterval: null,
      lastSyncTime: null,
      // Track recently modified threads to preserve during refresh
      recentlyModified: new Map(), // ref -> { folder, thread, expires }
      // Pending attachments for response
      pendingLocation: null,
      pendingAudio: null,
      pendingFile: null,
      audioRecorder: null,
      audioTimer: null
    };

    function init() {
      // Check for local API mode first
      if (state.isLocalMode && state.config?.token && state.config?.executorId) {
        // Local API mode - use LocalApiExchange
        const baseUrl = getApiBaseUrl();
        const exchangeId = state.config.exchangeId || 'home';
        state.github = new LocalApiExchange(baseUrl, state.config.token, exchangeId);
        state.view = 'main';
        render();
        refresh();
        startPeriodicSync();
      } else if (state.config?.token && state.config?.repo && state.config?.executorId) {
        const [owner, repo] = state.config.repo.split('/');
        state.github = new GitHubExchange(owner, repo, state.config.token);
        state.view = 'main';
        render();
        refresh();
        // Start periodic sync (every 30 seconds)
        startPeriodicSync();
      } else {
        state.view = 'setup';
        state.setupStep = 1;
        render();
      }
    }

    function startPeriodicSync() {
      if (state.syncInterval) clearInterval(state.syncInterval);
      state.syncInterval = setInterval(async () => {
        // Skip sync while viewing thread detail (to avoid clearing input state)
        if (!state.github || state.view !== 'main' || state.selectedThread) return;
        const previousThreads = JSON.stringify(state.threads.executing);
        await refresh();
        const currentThreads = JSON.stringify(state.threads.executing);
        // Check if any needs_input threads now have replies
        if (previousThreads !== currentThreads) {
          checkForAnsweredQuestions();
        }
        state.lastSyncTime = Date.now();
      }, 30000);
    }

    function checkForAnsweredQuestions() {
      const myId = state.config?.executorId;
      if (!myId) return;

      for (const thread of state.threads.executing || []) {
        if (hasNewAnswer(thread, myId)) {
          // Show notification if supported
          if ('Notification' in window && Notification.permission === 'granted') {
            new Notification('Question Answered', {
              body: `Reply received for: ${thread.intent}`,
              icon: '/icons/icon-192.png',
              tag: thread.ref
            });
          }
        }
      }
    }

    // Check if a thread has a reply after a needs_input status from this executor
    function hasNewAnswer(thread, executorId) {
      const messages = thread.messages || [];
      let foundNeedsInput = false;
      for (const msg of messages) {
        for (const item of msg.MESS || []) {
          if (item.status?.code === 'needs_input' && item.status?.executor === executorId) {
            foundNeedsInput = true;
          }
          if (foundNeedsInput && (item.reply || item.answer)) {
            return true;
          }
        }
      }
      return false;
    }

    // ============ Render Functions ============
    function render() {
      const app = document.getElementById('app');
      
      switch (state.view) {
        case 'setup':
          app.innerHTML = renderSetup();
          bindSetupEvents();
          break;
        case 'settings':
          app.innerHTML = renderSettings();
          bindSettingsEvents();
          break;
        case 'main':
          app.innerHTML = renderMain();
          bindMainEvents();
          if (state.selectedThread) {
            app.innerHTML = renderThreadDetail();
            bindDetailEvents();
          }
          if (state.showNewRequest) {
            app.insertAdjacentHTML('beforeend', renderNewRequestModal());
            bindNewRequestEvents();
          }
          if (state.lightboxImage) {
            app.insertAdjacentHTML('beforeend', renderLightbox());
            bindLightboxEvents();
          }
          break;
        default:
          app.innerHTML = '<div class="p-8 text-center">Loading...</div>';
      }
      
      // Update theme icons after render
      updateThemeIcons();
    }

    function renderSetup() {
      const steps = [
        { num: 1, label: 'Token', icon: 'ðŸ”‘' },
        { num: 2, label: 'Connect', icon: 'ðŸ”—' },
        { num: 3, label: 'Profile', icon: 'ðŸ‘¤' },
      ];
      
      return `
        <div class="min-h-screen gradient-mesh">
          <div class="container pt-12 pb-8" style="max-width:28rem">
            <!-- Logo & Header -->
            <div class="text-center mb-10">
              <div class="icon-box icon-box-lg bg-mess shadow-mess" style="margin:0 auto 1.5rem;background:linear-gradient(135deg,var(--mess-400),#10b981)">
                <span>ðŸ“¬</span>
              </div>
              <h1 class="text-4xl font-bold text-mess">MESS</h1>
              <p class="text-secondary mt-2">Meatspace Exchange for Synchronous Services</p>
            </div>
            
            <!-- Progress Steps -->
            <div class="flex justify-center items-center gap-3 mb-10">
              ${steps.map((s, i) => `
                <div class="flex items-center">
                  <div class="flex-col items-center" style="display:flex;flex-direction:column">
                    <div class="icon-box font-semibold" style="width:3rem;height:3rem;transition:all 0.3s;
                      ${state.setupStep > s.num 
                        ? 'background:var(--mess-500);color:white;box-shadow:0 4px 14px rgba(34,197,94,0.3)' 
                        : state.setupStep === s.num 
                          ? 'background:linear-gradient(135deg,var(--mess-400),#10b981);color:white;box-shadow:0 4px 14px rgba(34,197,94,0.3);transform:scale(1.1)' 
                          : 'background:var(--bg-hover);color:var(--text-muted)'}">
                      ${state.setupStep > s.num ? 'âœ“' : s.icon}
                    </div>
                    <span class="text-xs mt-2 font-medium" style="color:${state.setupStep >= s.num ? 'var(--mess-600)' : 'var(--text-muted)'}">${s.label}</span>
                  </div>
                  ${i < steps.length - 1 ? `
                    <div style="width:3rem;height:4px;margin:0 0.5rem;border-radius:2px;transition:all 0.3s;background:${state.setupStep > s.num ? 'var(--mess-500)' : 'var(--bg-hover)'}"></div>
                  ` : ''}
                </div>
              `).join('')}
            </div>
            
            <!-- Card -->
            <div class="card p-6 animate-fade">
              ${state.setupStep === 1 ? renderSetupStep1() : ''}
              ${state.setupStep === 2 ? renderSetupStep2() : ''}
              ${state.setupStep === 3 ? renderSetupStep3() : ''}
            </div>
            
            <!-- Theme Toggle -->
            <div class="flex justify-center mt-3">
              <button id="theme-toggle" class="btn btn-ghost text-sm">
                <span class="theme-light">ðŸŒ™ Dark mode</span>
                <span class="theme-dark hidden">â˜€ï¸ Light mode</span>
              </button>
            </div>
          </div>
        </div>
      `;
    }

    function renderSetupStep1() {
      // In local mode, show simplified setup
      if (state.isLocalMode) {
        return `
          <div class="space-y-6">
            <div>
              <h2 class="text-2xl font-bold text-primary">Local Server Detected</h2>
              <p class="text-secondary mt-2">You're running MESS on a local server. Register as an executor to get started.</p>
            </div>

            <div class="bg-mess-light rounded-2xl p-5 border border-mess">
              <h3 class="font-semibold text-mess mb-3 flex items-center gap-2">
                <span>ðŸ </span> Local Mode
              </h3>
              <p class="text-sm text-secondary">
                Your MESS server is running at <code class="mono bg-hover px-1 rounded">${window.location.origin}</code>
              </p>
            </div>

            <button id="next-step" class="btn btn-primary w-full">
              Register as Executor â†’
            </button>
          </div>
        `;
      }

      return `
        <div class="space-y-6">
          <div>
            <h2 class="text-2xl font-bold text-primary">Create a GitHub Token</h2>
            <p class="text-secondary mt-2">You'll need a Personal Access Token to connect to your exchange repository.</p>
          </div>

          <div class="bg-mess-light rounded-2xl p-5 border border-mess">
            <h3 class="font-semibold text-mess mb-3 flex items-center gap-2">
              <span>ðŸ“‹</span> Quick Setup
            </h3>
            <ol class="text-sm text-secondary space-y-2">
              <li class="flex gap-2"><span class="mono bg-hover px-1 rounded">1</span> Click the button below</li>
              <li class="flex gap-2"><span class="mono bg-hover px-1 rounded">2</span> Name: <code class="mono bg-hover px-1 rounded">MESS Exchange</code></li>
              <li class="flex gap-2"><span class="mono bg-hover px-1 rounded">3</span> Repository access: <strong>Only select repositories</strong></li>
              <li class="flex gap-2"><span class="mono bg-hover px-1 rounded">4</span> Permissions â†’ Contents: <strong>Read and write</strong></li>
            </ol>
          </div>

          <a href="https://github.com/settings/personal-access-tokens/new" target="_blank" class="btn btn-secondary w-full">
            <svg style="width:1.25rem;height:1.25rem" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
            Open GitHub Settings
          </a>

          <button id="next-step" class="btn btn-primary w-full">
            I have my token â†’
          </button>
        </div>
      `;
    }

    function renderSetupStep2() {
      // In local mode, show executor registration form
      if (state.isLocalMode) {
        return `
          <div class="space-y-6">
            <div>
              <h2 class="text-2xl font-bold text-primary">Register as Executor</h2>
              <p class="text-secondary mt-2">Enter an executor ID to register with the local server.</p>
            </div>

            <div class="space-y-4">
              <div>
                <label class="text-sm font-medium text-secondary mb-2" style="display:block">Executor ID</label>
                <input type="text" id="input-local-executor-id" value="${state.config?.executorId || ''}"
                  placeholder="e.g., my-phone" class="input">
                <p class="text-xs text-muted mt-1">A unique name for this device</p>
              </div>

              <div>
                <label class="text-sm font-medium text-secondary mb-2" style="display:block">Exchange ID</label>
                <input type="text" id="input-exchange-id" value="${state.config?.exchangeId || 'home'}"
                  placeholder="home" class="input">
                <p class="text-xs text-muted mt-1">Usually "home" - must match server config</p>
              </div>
            </div>

            ${state.error ? `
              <div class="bg-red-light border border-red rounded-xl p-4 animate-fade">
                <p class="text-red text-sm flex items-center gap-2">
                  <span>âš ï¸</span> ${state.error}
                </p>
              </div>
            ` : ''}

            ${state.connectionTest ? `
              <div class="bg-mess-light border border-mess rounded-xl p-4 animate-fade">
                <p class="text-mess font-medium flex items-center gap-2">
                  <span>âœ“</span> Registered successfully!
                </p>
                <p class="text-secondary text-sm mt-1 mono">${state.connectionTest.message || ''}</p>
              </div>
            ` : ''}

            <div class="flex gap-3">
              <button id="prev-step" class="btn btn-secondary flex-1">â† Back</button>
              <button id="register-local" class="btn btn-secondary flex-1 ${state.loading ? 'loading' : ''}">
                ${state.loading ? 'Registering...' : 'Register'}
              </button>
              <button id="next-step" ${!state.connectionTest ? 'disabled' : ''} class="btn btn-primary flex-1">
                Next â†’
              </button>
            </div>
          </div>
        `;
      }

      return `
        <div class="space-y-6">
          <div>
            <h2 class="text-2xl font-bold text-primary">Connect Your Repository</h2>
            <p class="text-secondary mt-2">Enter your token and repository details.</p>
          </div>

          <div class="space-y-4">
            <div>
              <label class="text-sm font-medium text-secondary mb-2" style="display:block">GitHub Token</label>
              <input type="password" id="input-token" value="${state.config?.token || ''}"
                placeholder="github_pat_xxxxx or ghp_xxxxx" class="input mono text-sm">
              <p class="text-xs text-muted mt-1">ðŸ”’ Stored locally in your browser only</p>
            </div>

            <div>
              <label class="text-sm font-medium text-secondary mb-2" style="display:block">Repository</label>
              <input type="text" id="input-repo" value="${state.config?.repo || ''}"
                placeholder="username/mess-exchange" class="input">
            </div>
          </div>

          ${state.error ? `
            <div class="bg-red-light border border-red rounded-xl p-4 animate-fade">
              <p class="text-red text-sm flex items-center gap-2">
                <span>âš ï¸</span> ${state.error}
              </p>
            </div>
          ` : ''}

          ${state.connectionTest ? `
            <div class="bg-mess-light border border-mess rounded-xl p-4 animate-fade">
              <p class="text-mess font-medium flex items-center gap-2">
                <span>âœ“</span> Connected to ${state.connectionTest.name}
              </p>
              <p class="text-secondary text-sm mt-1">
                ${state.connectionTest.private ? 'ðŸ”’ Private' : 'ðŸŒ Public'} repository
                ${state.connectionTest.permissions?.push ? ' Â· Write access âœ“' : ''}
              </p>
            </div>
          ` : ''}

          <div class="flex gap-3">
            <button id="prev-step" class="btn btn-secondary flex-1">â† Back</button>
            <button id="test-connection" class="btn btn-secondary flex-1 ${state.loading ? 'loading' : ''}">
              ${state.loading ? 'Testing...' : 'Test'}
            </button>
            <button id="next-step" ${!state.connectionTest ? 'disabled' : ''} class="btn btn-primary flex-1">
              Next â†’
            </button>
          </div>
        </div>
      `;
    }

    function renderSetupStep3() {
      const savedCaps = state.config?.capabilities || [];
      return `
        <div class="space-y-6">
          <div>
            <h2 class="text-2xl font-bold text-primary">Your Profile</h2>
            <p class="text-secondary mt-2">Tell us about yourself so requests can be routed to you.</p>
          </div>
          
          <div class="space-y-4">
            <div>
              <label class="text-sm font-medium text-secondary mb-2" style="display:block">Executor Name</label>
              <input type="text" id="input-executor-id" value="${state.config?.executorId || ''}"
                placeholder="e.g., teague-phone" class="input">
            </div>
            
            <div>
              <label class="text-sm font-medium text-secondary mb-2" style="display:block">Display Name</label>
              <input type="text" id="input-display-name" value="${state.config?.displayName || ''}"
                placeholder="e.g., Teague's Phone" class="input">
            </div>
          </div>
          
          <div>
            <label class="text-sm font-medium text-secondary mb-3" style="display:block">Capabilities</label>
            <div class="space-y-3 max-h-48 overflow-y-auto" style="padding-right:0.5rem">
              ${Object.entries(CAPABILITIES).map(([catKey, cat]) => `
                <div class="bg-hover rounded-xl p-3">
                  <div class="font-medium text-secondary mb-2 flex items-center gap-2">
                    <span>${cat.icon}</span> ${cat.label}
                  </div>
                  <div class="flex flex-wrap gap-2">
                    ${Object.entries(cat.items).map(([capKey, cap]) => `
                      <label class="chip ${savedCaps.includes(capKey) ? 'selected' : ''}" data-cap="${capKey}">
                        <input type="checkbox" class="cap-checkbox sr-only" data-cap="${capKey}" ${savedCaps.includes(capKey) ? 'checked' : ''}>
                        ${cap.label}
                      </label>
                    `).join('')}
                  </div>
                </div>
              `).join('')}
            </div>
            <div class="mt-3">
              <label class="text-xs text-muted mb-1" style="display:block">Custom capabilities (comma-separated)</label>
              <input type="text" id="input-custom-caps" value="${getCustomCapabilities(savedCaps).join(', ')}"
                placeholder="e.g., garage-door-access, vacuum-floor" class="input text-sm">
            </div>
          </div>

          <label class="flex items-center gap-3 p-3 bg-hover rounded-xl cursor-pointer">
            <input type="checkbox" id="input-can-request" ${state.config?.canRequest !== false ? 'checked' : ''}>
            <div>
              <div class="font-medium text-primary">Can create requests</div>
              <div class="text-xs text-muted">Allow posting new requests from this client</div>
            </div>
          </label>
          
          ${state.error ? `
            <div class="bg-red-light border border-red rounded-xl p-4">
              <p class="text-red text-sm">${state.error}</p>
            </div>
          ` : ''}
          
          <div class="flex gap-3">
            <button id="prev-step" class="btn btn-secondary">â† Back</button>
            <button id="finish-setup" class="btn btn-primary flex-1">
              âœ“ Complete Setup
            </button>
          </div>
        </div>
      `;
    }

    function renderSettings() {
      const savedCaps = state.config?.capabilities || [];
      const savedNotifs = state.config?.notifications || [];
      
      return `
        <div class="min-h-screen bg-page">
          <!-- Header -->
          <div class="glass sticky p-4 flex items-center gap-4">
            <button id="back-to-main" class="btn btn-ghost">
              <svg style="width:1.5rem;height:1.5rem" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
              </svg>
            </button>
            <h1 class="text-xl font-bold">Settings</h1>
            <div class="flex-1"></div>
            <button id="theme-toggle" class="btn btn-ghost">
              <span class="theme-light">ðŸŒ™</span>
              <span class="theme-dark hidden">â˜€ï¸</span>
            </button>
          </div>
          
          <div class="container space-y-6 pb-24" style="max-width:28rem">
            <!-- Connection -->
            <div class="card p-5">
              <h2 class="font-semibold text-primary mb-4 flex items-center gap-2">
                <span>ðŸ”—</span> Connection
              </h2>
              <div class="space-y-4">
                <div>
                  <label class="text-sm text-secondary mb-1" style="display:block">Repository</label>
                  <input type="text" id="settings-repo" value="${state.config?.repo || ''}" class="input text-sm">
                </div>
                <div>
                  <label class="text-sm text-secondary mb-1" style="display:block">Token</label>
                  <input type="password" id="settings-token" value="${state.config?.token || ''}" class="input text-sm mono">
                </div>
              </div>
            </div>
            
            <!-- Profile -->
            <div class="card p-5">
              <h2 class="font-semibold text-primary mb-4 flex items-center gap-2">
                <span>ðŸ‘¤</span> Profile
              </h2>
              <div class="space-y-4">
                <div>
                  <label class="text-sm text-secondary mb-1" style="display:block">Executor ID</label>
                  <input type="text" id="settings-executor-id" value="${state.config?.executorId || ''}" class="input text-sm">
                </div>
                <div>
                  <label class="text-sm text-secondary mb-1" style="display:block">Display Name</label>
                  <input type="text" id="settings-display-name" value="${state.config?.displayName || ''}" class="input text-sm">
                </div>
                <label class="flex items-center gap-3 cursor-pointer">
                  <input type="checkbox" id="settings-can-request" ${state.config?.canRequest !== false ? 'checked' : ''}>
                  <span class="text-sm text-secondary">Can create requests</span>
                </label>
              </div>
            </div>
            
            <!-- Capabilities -->
            <div class="card p-5">
              <h2 class="font-semibold text-primary mb-4 flex items-center gap-2">
                <span>âš¡</span> Capabilities
              </h2>
              <div class="space-y-3 max-h-48 overflow-y-auto">
                ${Object.entries(CAPABILITIES).map(([catKey, cat]) => `
                  <div>
                    <div class="text-sm font-medium text-secondary mb-2">${cat.icon} ${cat.label}</div>
                    <div class="flex flex-wrap gap-1">
                      ${Object.entries(cat.items).map(([capKey, cap]) => `
                        <label class="chip ${savedCaps.includes(capKey) ? 'selected' : ''}" style="font-size:0.7rem">
                          <input type="checkbox" class="settings-cap sr-only" data-cap="${capKey}" ${savedCaps.includes(capKey) ? 'checked' : ''}>
                          ${cap.label}
                        </label>
                      `).join('')}
                    </div>
                  </div>
                `).join('')}
              </div>
              <div class="mt-3 pt-3 border-t">
                <label class="text-xs text-muted mb-1" style="display:block">Custom capabilities (comma-separated)</label>
                <input type="text" id="settings-custom-caps" value="${getCustomCapabilities(savedCaps).join(', ')}"
                  placeholder="e.g., garage-door-access, vacuum-floor" class="input text-sm">
              </div>
            </div>
            
            <!-- Notifications -->
            <div class="card p-5">
              <h2 class="font-semibold text-primary mb-4 flex items-center gap-2">
                <span>ðŸ””</span> Notifications
              </h2>
              
              <div id="notif-list" class="space-y-2 mb-4">
                ${savedNotifs.map((n, i) => `
                  <div class="flex items-center gap-2 p-3 bg-hover rounded-xl text-sm animate-fade">
                    <span class="icon-box bg-mess-light text-mess" style="width:2rem;height:2rem;font-size:0.875rem">
                      ${getNotifIcon(n.type)}
                    </span>
                    <div class="flex-1 min-w-0">
                      <div class="font-medium text-primary capitalize">${n.type.replace('_', ' ')}</div>
                      <div class="text-xs text-muted truncate">${getNotifSummary(n)}</div>
                    </div>
                    <button class="remove-notif btn btn-ghost text-red" data-index="${i}">
                      <svg style="width:1.25rem;height:1.25rem" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                      </svg>
                    </button>
                  </div>
                `).join('')}
                ${savedNotifs.length === 0 ? '<p class="text-sm text-muted italic text-center py-4">No notifications configured</p>' : ''}
              </div>
              
              <div class="border-t pt-4">
                <select id="notif-type" class="input text-sm">
                  <option value="">+ Add notification channel...</option>
                  <option value="ntfy">ðŸ“± ntfy.sh (free push)</option>
                  <option value="google_chat">ðŸ’¬ Google Chat</option>
                  <option value="gmail">ðŸ“§ Gmail</option>
                  <option value="slack">ðŸ’¼ Slack</option>
                  <option value="pushover">ðŸ“² Pushover</option>
                  <option value="webhook">ðŸ”— Custom webhook</option>
                </select>
                <div id="notif-config" class="mt-3 hidden animate-fade"></div>
              </div>
            </div>
            
            <!-- Preferences -->
            <div class="card p-5">
              <h2 class="font-semibold text-primary mb-4 flex items-center gap-2">
                <span>âš™ï¸</span> Preferences
              </h2>
              <div class="space-y-4">
                <div>
                  <label class="text-sm text-secondary mb-1" style="display:block">Minimum priority to notify</label>
                  <select id="settings-min-priority" class="input text-sm">
                    <option value="background" ${state.config?.preferences?.min_priority === 'background' ? 'selected' : ''}>Background (all)</option>
                    <option value="normal" ${state.config?.preferences?.min_priority === 'normal' || !state.config?.preferences?.min_priority ? 'selected' : ''}>Normal+</option>
                    <option value="elevated" ${state.config?.preferences?.min_priority === 'elevated' ? 'selected' : ''}>Elevated+</option>
                    <option value="urgent" ${state.config?.preferences?.min_priority === 'urgent' ? 'selected' : ''}>Urgent only</option>
                  </select>
                </div>
                <label class="flex items-center gap-3 cursor-pointer">
                  <input type="checkbox" id="settings-quiet-hours" ${state.config?.preferences?.quiet_hours?.enabled ? 'checked' : ''}>
                  <span class="text-sm text-secondary">Enable quiet hours</span>
                </label>
                <div id="quiet-hours-config" class="${state.config?.preferences?.quiet_hours?.enabled ? '' : 'hidden'} ml-8 flex items-center gap-2">
                  <input type="time" id="settings-quiet-start" value="${state.config?.preferences?.quiet_hours?.start || '22:00'}" class="input text-sm" style="width:7rem">
                  <span class="text-muted">to</span>
                  <input type="time" id="settings-quiet-end" value="${state.config?.preferences?.quiet_hours?.end || '07:00'}" class="input text-sm" style="width:7rem">
                </div>
              </div>
            </div>
            
            <!-- Actions -->
            <div class="space-y-3">
              <button id="save-settings" class="btn btn-primary w-full">Save Changes</button>
              <button id="reset-settings" class="btn w-full border-2 border-red text-red" style="background:transparent">
                Reset & Start Over
              </button>
            </div>
          </div>
        </div>
      `;
    }

    function getNotifIcon(type) {
      const icons = { ntfy: 'ðŸ“±', google_chat: 'ðŸ’¬', gmail: 'ðŸ“§', slack: 'ðŸ’¼', pushover: 'ðŸ“²', email: 'âœ‰ï¸', sms: 'ðŸ“±', webhook: 'ðŸ”—' };
      return icons[type] || 'ðŸ””';
    }

    function getNotifSummary(n) {
      switch (n.type) {
        case 'ntfy': return n.topic || 'topic not set';
        case 'google_chat': return 'Google Chat webhook';
        case 'gmail': return n.to || '(your Gmail)';
        case 'slack': return 'Slack webhook';
        case 'pushover': return n.user_key?.slice(0, 8) + '...' || 'user key not set';
        case 'email': return n.address || 'email not set';
        case 'sms': return n.phone || 'phone not set';
        case 'webhook': return n.url || 'URL not set';
        default: return '';
      }
    }

    function renderNotifConfig(type) {
      const configs = {
        ntfy: `
          <div class="space-y-3">
            <input type="text" id="notif-ntfy-topic" placeholder="Topic name (e.g., my-mess-alerts)" class="input text-sm">
            <input type="text" id="notif-ntfy-server" placeholder="Server (default: https://ntfy.sh)" class="input text-sm">
            <button id="add-notif-btn" class="btn btn-primary w-full btn-sm">Add ntfy</button>
          </div>`,
        google_chat: `
          <div class="space-y-3">
            <input type="text" id="notif-gchat-webhook" placeholder="Google Chat webhook URL" class="input text-sm mono">
            <p class="text-xs text-muted">Space â†’ Apps & integrations â†’ Webhooks</p>
            <button id="add-notif-btn" class="btn btn-primary w-full btn-sm">Add Google Chat</button>
          </div>`,
        gmail: `
          <div class="space-y-3">
            <input type="email" id="notif-gmail-to" placeholder="Send to (default: your Gmail)" class="input text-sm">
            <p class="text-xs text-muted">Set GMAIL_EMAIL and GMAIL_APP_PASSWORD as repo secrets</p>
            <button id="add-notif-btn" class="btn btn-primary w-full btn-sm">Add Gmail</button>
          </div>`,
        slack: `
          <div class="space-y-3">
            <input type="text" id="notif-slack-webhook" placeholder="Slack webhook URL" class="input text-sm mono">
            <button id="add-notif-btn" class="btn btn-primary w-full btn-sm">Add Slack</button>
          </div>`,
        pushover: `
          <div class="space-y-3">
            <input type="text" id="notif-pushover-user" placeholder="User key" class="input text-sm mono">
            <p class="text-xs text-muted">App token is set as repo secret PUSHOVER_APP_TOKEN</p>
            <button id="add-notif-btn" class="btn btn-primary w-full btn-sm">Add Pushover</button>
          </div>`,
        webhook: `
          <div class="space-y-3">
            <input type="url" id="notif-webhook-url" placeholder="https://example.com/webhook" class="input text-sm mono">
            <button id="add-notif-btn" class="btn btn-primary w-full btn-sm">Add Webhook</button>
          </div>`
      };
      return configs[type] || '';
    }

    // Filter threads based on current filter settings
    function filterThreads(threads, folder) {
      let filtered = threads;
      const myCaps = state.config?.capabilities || [];
      const myId = state.config?.executorId;

      // In the executing folder, always hide threads claimed by other executors
      if (folder === 'executing' && myId) {
        filtered = filtered.filter(t => {
          // Show if no executor assigned yet, or if I'm the executor
          if (!t.executor) return true;
          return t.executor === myId;
        });
      }

      if (state.filters.capableOnly && myCaps.length > 0) {
        filtered = filtered.filter(t => {
          // If messages not loaded yet, show the thread
          if (!t.messages || t.messages.length === 0) return true;
          const requestMsg = t.messages[0]?.MESS?.find(m => m.request);
          const requires = requestMsg?.request?.requires || [];
          // Show if no requirements or if I have at least one matching capability
          if (requires.length === 0) return true;
          const reqIds = requires.map(r => typeof r === 'string' ? r : Object.keys(r)[0]);
          return reqIds.some(req => myCaps.includes(req));
        });
      }

      if (state.filters.myClaimsOnly && myId) {
        filtered = filtered.filter(t => {
          // Check thread envelope executor field or status messages
          if (t.executor === myId) return true;
          return t.messages?.some(m =>
            m.MESS?.some(item => item.status?.executor === myId)
          );
        });
      }

      // Filter for threads awaiting answer (needs_input with no reply yet)
      if (state.filters.awaitingAnswer && myId) {
        filtered = filtered.filter(t => {
          return t.status === 'needs_input' && !hasNewAnswer(t, myId);
        });
      }

      // Filter for threads that have received an answer
      if (state.filters.hasNewAnswer && myId) {
        filtered = filtered.filter(t => hasNewAnswer(t, myId));
      }

      return filtered;
    }

    function renderMain() {
      const allThreads = state.threads[state.currentFolder] || [];
      const threads = filterThreads(allThreads, state.currentFolder);
      const filteredCount = allThreads.length - threads.length;

      const folders = [
        { key: 'received', label: 'Inbox', icon: 'ðŸ“¥', count: state.threads.received?.length },
        { key: 'executing', label: 'Active', icon: 'â–¶ï¸', count: state.threads.executing?.length },
        { key: 'finished', label: 'Done', icon: 'âœ…', count: state.threads.finished?.length },
        { key: 'canceled', label: 'Closed', icon: 'âŒ', count: state.threads.canceled?.length }
      ];

      const canRequest = state.config?.canRequest !== false;
      const hasFilters = state.filters.capableOnly || state.filters.myClaimsOnly ||
                         state.filters.awaitingAnswer || state.filters.hasNewAnswer;
      
      return `
        <div class="h-screen flex flex-col bg-page">
          <!-- Header -->
          <div class="glass p-4 flex items-center gap-3">
            <div class="flex items-center gap-3">
              <div class="icon-box bg-mess shadow-mess" style="background:linear-gradient(135deg,var(--mess-400),#10b981)">
                <span>ðŸ“¬</span>
              </div>
              <div>
                <h1 class="text-lg font-bold text-primary">MESS</h1>
                <p class="text-xs text-muted">${state.config?.displayName || state.config?.executorId}</p>
              </div>
            </div>
            <div class="flex-1"></div>
            <button id="refresh" class="btn btn-ghost ${state.loading ? 'loading' : ''}" title="Refresh">
              <svg style="width:1.25rem;height:1.25rem" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
              </svg>
            </button>
            <button id="theme-toggle" class="btn btn-ghost">
              <span class="theme-light">ðŸŒ™</span>
              <span class="theme-dark hidden">â˜€ï¸</span>
            </button>
            <button id="open-settings" class="btn btn-ghost" title="Settings">
              <svg style="width:1.25rem;height:1.25rem" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
              </svg>
            </button>
            ${canRequest ? `
              <button id="new-request" class="btn btn-primary btn-sm" title="New Request">
                <span class="hidden-sm">New</span>
                <span class="show-sm">+</span>
              </button>
            ` : ''}
          </div>
          
          <!-- Tabs -->
          <div class="flex gap-1 overflow-x-auto bg-card border-b" style="padding:0 0.5rem">
            ${folders.map(f => `
              <button data-folder="${f.key}" class="tab ${state.currentFolder === f.key ? 'active' : ''}">
                <span>${f.icon}</span>
                <span>${f.label}</span>
                ${f.count ? `<span class="badge bg-hover text-muted" style="margin-left:0.25rem">${f.count}</span>` : ''}
              </button>
            `).join('')}
          </div>

          <!-- Filters -->
          <div class="flex items-center gap-2 px-3 py-2 bg-card border-b text-sm flex-wrap">
            <span class="text-muted">Filter:</span>
            <label class="chip ${state.filters.capableOnly ? 'selected' : ''}" style="font-size:0.75rem">
              <input type="checkbox" id="filter-capable" class="sr-only" ${state.filters.capableOnly ? 'checked' : ''}>
              My capabilities
            </label>
            ${state.currentFolder === 'executing' ? `
              <label class="chip ${state.filters.myClaimsOnly ? 'selected' : ''}" style="font-size:0.75rem">
                <input type="checkbox" id="filter-my-claims" class="sr-only" ${state.filters.myClaimsOnly ? 'checked' : ''}>
                My claims
              </label>
              <label class="chip ${state.filters.awaitingAnswer ? 'selected' : ''}" style="font-size:0.75rem">
                <input type="checkbox" id="filter-awaiting" class="sr-only" ${state.filters.awaitingAnswer ? 'checked' : ''}>
                Awaiting answer
              </label>
              <label class="chip ${state.filters.hasNewAnswer ? 'selected' : ''}" style="font-size:0.75rem">
                <input type="checkbox" id="filter-answered" class="sr-only" ${state.filters.hasNewAnswer ? 'checked' : ''}>
                Has reply
              </label>
            ` : ''}
            ${hasFilters && filteredCount > 0 ? `
              <span class="text-xs text-muted ml-auto">${filteredCount} hidden</span>
            ` : ''}
          </div>

          <!-- Thread List -->
          <div class="flex-1 overflow-y-auto">
            ${state.loading && threads.length === 0 ? `
              <div class="p-8 text-center">
                <div class="icon-box icon-box-lg bg-hover loading" style="margin:0 auto 1rem">
                  <span>ðŸ“¬</span>
                </div>
                <p class="text-muted">Loading...</p>
              </div>
            ` : threads.length === 0 ? `
              <div class="p-8 text-center">
                <div class="icon-box icon-box-lg bg-hover" style="margin:0 auto 1rem">
                  <span>ðŸ“­</span>
                </div>
                <p class="text-muted">No threads here</p>
              </div>
            ` : `
              <div>
                ${threads.map(t => renderThreadRow(t)).join('')}
              </div>
            `}
          </div>
        </div>
      `;
    }

    function renderThreadRow(thread) {
      const statusConfig = {
        pending: { bg: 'bg-blue-light', text: 'text-blue', icon: 'â³' },
        claimed: { bg: 'bg-amber-light', text: 'text-amber', icon: 'ðŸ‘‹' },
        in_progress: { bg: 'bg-amber-light', text: 'text-amber', icon: 'ðŸ”„' },
        needs_input: { bg: 'bg-purple-light', text: 'text-purple', icon: 'â“' },
        completed: { bg: 'bg-mess-light', text: 'text-green', icon: 'âœ…' },
        failed: { bg: 'bg-red-light', text: 'text-red', icon: 'âŒ' },
        declined: { bg: 'bg-gray-light', text: 'text-muted', icon: 'ðŸš«' }
      };
      
      const status = statusConfig[thread.status] || statusConfig.pending;
      const wantsImage = thread.messages?.some(m => m.MESS?.some(item => item.request?.response_hint?.includes('image')));
      const priorityColors = { urgent: 'text-red', elevated: 'text-amber', normal: 'text-muted', background: 'text-muted' };
      
      return `
        <div class="thread-row animate-fade" data-ref="${thread.ref}">
          <div class="flex items-start gap-3">
            <div class="icon-box ${status.bg}">
              <span>${status.icon}</span>
            </div>
            <div class="flex-1 min-w-0">
              <div class="flex items-center gap-2 mb-1">
                <span class="badge ${status.bg} ${status.text}">${thread.status}</span>
                ${thread.priority !== 'normal' ? `<span class="text-xs ${priorityColors[thread.priority]}">â— ${thread.priority}</span>` : ''}
                ${wantsImage ? '<span class="text-xs">ðŸ“·</span>' : ''}
              </div>
              <p class="font-medium text-primary truncate">${thread.intent}</p>
              <p class="text-sm text-muted mt-1">${thread.ref} Â· ${formatTime(thread.updated)}</p>
            </div>
            ${thread.status === 'pending' ? `
              <div class="flex gap-1 shrink-0">
                <button class="quick-claim btn btn-primary btn-sm" data-ref="${thread.ref}" title="Claim">
                  Claim
                </button>
                <button class="quick-complete btn btn-ghost btn-sm border" data-ref="${thread.ref}" title="Quick complete (claim + done)">
                  âœ“
                </button>
              </div>
            ` : `
              <svg class="shrink-0 text-muted" style="width:1.25rem;height:1.25rem" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
              </svg>
            `}
          </div>
        </div>
      `;
    }

    function renderThreadDetail() {
      const t = state.selectedThread;
      const canClaim = t.status === 'pending';
      const canRespond = ['claimed', 'in_progress'].includes(t.status);
      const needsInput = t.status === 'needs_input';
      const wantsImage = t.messages?.some(m => m.MESS?.some(item => item.request?.response_hint?.includes('image')));
      
      return `
        <div class="h-screen flex flex-col bg-page">
          <!-- Header -->
          <div class="glass p-4">
            <div class="flex items-start gap-3">
              <div class="flex-1 min-w-0">
                <h2 class="text-lg font-bold text-primary">${t.intent}</h2>
                <p class="text-sm text-muted mt-1">
                  <span class="mono">${t.ref}</span> Â· from ${t.requestor}${t.executor ? ` Â· ${t.executor}` : ''}
                </p>
              </div>
              <button id="back" class="btn btn-ghost p-2" title="Close">
                <svg style="width:1.25rem;height:1.25rem" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
              </button>
            </div>
          </div>
          
          <!-- Messages -->
          <div class="flex-1 overflow-y-auto p-4 space-y-4">
            ${(t.messages || []).map(m => renderMessage(m)).join('')}
          </div>
          
          <!-- Actions -->
          <div class="p-4 border-t bg-card">
            ${canClaim ? `
              <div class="space-y-3">
                <input type="text" id="response-text" placeholder="Ask a question before claiming..." class="input w-full">
                <div class="flex gap-3">
                  <button id="action-claim" class="btn btn-primary flex-1">ðŸ‘‹ Claim</button>
                  <button id="action-needs-input-unclaimed" class="btn btn-secondary flex-1">â“ Need Info</button>
                  <button id="action-decline" class="btn btn-ghost border">Decline</button>
                </div>
              </div>
            ` : ''}
            
            ${needsInput ? `
              <div class="text-center py-3">
                <span class="flex items-center justify-center gap-2 text-purple font-medium">
                  <span>â³</span> Waiting for input from requestor
                </span>
              </div>
            ` : ''}
            
            ${canRespond ? `
              <div class="space-y-3">
                ${wantsImage ? '<p class="text-sm text-blue flex items-center gap-2"><span>ðŸ“·</span> Photo requested</p>' : ''}
                <div class="flex gap-2">
                  <input type="text" id="response-text" placeholder="Add response..." class="input flex-1">
                  <label class="btn btn-ghost border rounded-xl cursor-pointer" title="Add photo">
                    ðŸ“·
                    <input type="file" id="photo-input" accept="image/*" capture="environment" class="hidden">
                  </label>
                  <button id="location-btn" class="btn btn-ghost border rounded-xl" title="Add location">ðŸ“</button>
                  <button id="audio-btn" class="btn btn-ghost border rounded-xl" title="Record audio">ðŸŽ¤</button>
                  <label class="btn btn-ghost border rounded-xl cursor-pointer" title="Attach file">
                    ðŸ“Ž
                    <input type="file" id="file-input" class="hidden">
                  </label>
                </div>
                <div id="photo-preview" class="hidden animate-fade">
                  <img id="photo-img" class="rounded-xl max-h-32 border">
                  <button id="remove-photo" class="text-red text-sm mt-1">Remove photo</button>
                </div>
                <div id="location-preview" class="hidden animate-fade p-3 bg-hover rounded-xl">
                  <div class="flex items-center gap-2">
                    <span>ðŸ“</span>
                    <span id="location-text" class="text-sm flex-1"></span>
                    <button id="remove-location" class="text-red text-sm">Remove</button>
                  </div>
                </div>
                <div id="audio-preview" class="hidden animate-fade p-3 bg-hover rounded-xl">
                  <div class="flex items-center gap-2">
                    <span>ðŸŽ¤</span>
                    <audio id="audio-player" controls class="flex-1 h-8"></audio>
                    <button id="remove-audio" class="text-red text-sm">Remove</button>
                  </div>
                </div>
                <div id="audio-recording" class="hidden animate-fade p-3 bg-red-light rounded-xl">
                  <div class="flex items-center gap-2">
                    <span class="loading">ðŸ”´</span>
                    <span class="text-sm flex-1">Recording... <span id="audio-duration">0:00</span></span>
                    <button id="stop-audio" class="btn btn-sm btn-secondary">Stop</button>
                  </div>
                </div>
                <div id="file-preview" class="hidden animate-fade p-3 bg-hover rounded-xl">
                  <div class="flex items-center gap-2">
                    <span id="file-icon">ðŸ“„</span>
                    <div class="flex-1 min-w-0">
                      <div id="file-name" class="text-sm font-medium truncate"></div>
                      <div id="file-meta" class="text-xs text-muted"></div>
                    </div>
                    <button id="remove-file" class="text-red text-sm">Remove</button>
                  </div>
                </div>
                <div id="main-actions" class="flex gap-2">
                  <button id="action-complete" class="btn btn-primary flex-1">âœ“ Complete</button>
                  <button id="action-more" class="btn btn-secondary">More â–¼</button>
                </div>
                <div id="more-actions" class="hidden space-y-2 pt-2 border-t animate-fade">
                  <div class="flex gap-2">
                    <button id="action-needs-input" class="flex-1 text-sm py-2 px-4 border-2 border-purple text-purple rounded-xl" style="background:transparent">
                      Need Info
                    </button>
                    <button id="action-failed" class="flex-1 text-sm py-2 px-4 border-2 border-red text-red rounded-xl" style="background:transparent">
                      Can't Do
                    </button>
                  </div>
                  <button id="action-back-to-main" class="w-full text-sm py-2 text-muted">â–² Back</button>
                </div>
              </div>
            ` : ''}
            
            ${t.status === 'completed' ? '<p class="text-center text-green font-medium py-3">âœ“ Completed</p>' : ''}
            ${['failed', 'declined', 'expired', 'cancelled'].includes(t.status) ? '<p class="text-center text-muted py-3">This thread is closed</p>' : ''}
          </div>
        </div>
      `;
    }

    // Render all request fields, including non-standard ones
    function renderRequestContent(req) {
      const knownFields = ['intent', 'context', 'response_hint', 'requires', 'priority', 're', 'requestor'];
      const extraFields = Object.keys(req).filter(k => !knownFields.includes(k));

      let html = `<p class="font-medium text-primary">${req.intent}</p>`;

      if (req.context) {
        html += `<ul class="mt-2 text-sm text-secondary space-y-1">${req.context.map(c => `<li class="flex gap-2"><span class="text-muted">â€¢</span> ${c}</li>`).join('')}</ul>`;
      }

      if (req.priority && req.priority !== 'normal') {
        const colors = { urgent: 'text-red', elevated: 'text-amber', background: 'text-muted' };
        html += `<p class="mt-2 text-sm ${colors[req.priority] || 'text-secondary'}">Priority: ${req.priority}</p>`;
      }

      if (req.requires && req.requires.length > 0) {
        const caps = req.requires.map(r => typeof r === 'string' ? r : Object.keys(r)[0]);
        html += `<p class="mt-2 text-xs text-muted">Requires: ${caps.join(', ')}</p>`;
      }

      if (req.response_hint) {
        html += `<p class="mt-2 text-xs text-muted flex items-center gap-1"><span>ðŸ“Ž</span> Wants: ${req.response_hint.join(', ')}</p>`;
      }

      // Render any additional/custom fields
      for (const field of extraFields) {
        const value = req[field];
        const displayValue = typeof value === 'object' ? JSON.stringify(value) : String(value);
        html += `<p class="mt-2 text-xs text-muted"><span class="text-secondary">${field}:</span> ${displayValue}</p>`;
      }

      return html;
    }

    function renderMessage(msg) {
      const isAgent = msg.from?.includes('agent') || msg.from?.includes('claude');
      const isExchange = msg.from === 'exchange';
      const content = {};
      (msg.MESS || []).forEach(item => {
        const key = Object.keys(item)[0];
        content[key] = item[key];
      });

      const align = isAgent || isExchange ? '' : 'justify-end';
      const bgClass = isAgent ? 'bg-blue-light' : isExchange ? 'bg-gray-light' : 'bg-mess-light';
      const icon = isAgent ? 'ðŸ¤–' : isExchange ? 'ðŸ“¨' : 'ðŸ‘¤';
      
      return `
        <div class="animate-slide flex ${align}">
          <div style="max-width:85%;${isExchange ? 'width:100%' : ''}">
            <div class="flex items-center gap-2 mb-1">
              <span>${icon}</span>
              <span class="text-xs font-medium text-secondary">${msg.from}</span>
              <span class="text-xs text-muted">${formatTime(msg.received)}</span>
            </div>
            <div class="rounded-2xl p-4 ${bgClass} border">
              ${content.request ? renderRequestContent(content.request) : ''}
              ${content.ack ? `<p class="text-sm text-secondary">âœ“ Acknowledged as <span class="mono">${content.ack.ref}</span></p>` : ''}
              ${content.status ? `
                <p class="font-medium text-primary">Status: ${content.status.code}</p>
                ${content.status.message ? `<p class="mt-1 text-sm text-secondary">${content.status.message}</p>` : ''}
              ` : ''}
              ${content.response ? `
                ${content.response.content?.map(c => {
                  if (typeof c === 'object' && c.image) {
                    return `<img src="${c.image}" class="rounded-xl border mb-2 cursor-pointer lightbox-trigger" style="max-width:100%;max-height:200px" title="Click to enlarge">`;
                  } else if (typeof c === 'object' && c.location) {
                    const loc = c.location;
                    const mapsUrl = `https://www.google.com/maps?q=${loc.lat},${loc.lng}`;
                    return `<div class="flex items-center gap-2 p-2 bg-hover rounded-lg mb-2">
                      <span>ðŸ“</span>
                      <a href="${mapsUrl}" target="_blank" class="text-sm text-blue hover:underline">
                        ${loc.lat.toFixed(6)}, ${loc.lng.toFixed(6)}
                      </a>
                      <span class="text-xs text-muted">(Â±${loc.accuracy}m)</span>
                    </div>`;
                  } else if (typeof c === 'object' && c.audio) {
                    return `<div class="mb-2">
                      <audio controls src="${c.audio}" class="w-full h-10"></audio>
                    </div>`;
                  } else if (typeof c === 'object' && c.file) {
                    const f = c.file;
                    const icon = typeof getFileIcon === 'function' ? getFileIcon(f.type) : 'ðŸ“„';
                    return `<div class="flex items-center gap-2 p-2 bg-hover rounded-lg mb-2">
                      <span>${icon}</span>
                      <div class="flex-1 min-w-0">
                        <a href="${f.data}" download="${f.name}" class="text-sm text-blue hover:underline truncate block">${f.name}</a>
                        <span class="text-xs text-muted">${f.type} Â· ${typeof formatFileSize === 'function' ? formatFileSize(f.size) : f.size + ' bytes'}</span>
                      </div>
                    </div>`;
                  } else if (typeof c === 'string') {
                    return `<div class="whitespace-pre-wrap text-sm text-secondary">${c}</div>`;
                  }
                  return '';
                }).join('') || ''}
                ${content.response.notes ? `<p class="mt-3 text-sm font-medium text-primary border-t pt-3">ðŸ“ ${content.response.notes}</p>` : ''}
              ` : ''}
              ${content.reply ? `
                <div class="space-y-2">
                  ${content.reply.text ? `<p class="text-sm text-secondary">${content.reply.text}</p>` : ''}
                  ${content.reply.content?.map(c => {
                    if (typeof c === 'object' && c.image) {
                      return `<img src="${c.image}" class="rounded-xl border mb-2 cursor-pointer lightbox-trigger" style="max-width:100%;max-height:200px" title="Click to enlarge">`;
                    } else if (typeof c === 'string') {
                      return `<div class="whitespace-pre-wrap text-sm text-secondary">${c}</div>`;
                    }
                    return '';
                  }).join('') || ''}
                </div>
              ` : ''}
              ${content.answer ? `
                <div class="space-y-2">
                  <p class="text-xs text-muted flex items-center gap-1"><span>ðŸ’¬</span> Answer to question</p>
                  <p class="text-sm text-secondary">${content.answer.value || content.answer.text || ''}</p>
                </div>
              ` : ''}
            </div>
          </div>
        </div>
      `;
    }

    function renderLightbox() {
      return `
        <div id="lightbox-backdrop" class="fixed inset-0 bg-black/90 z-50 flex items-center justify-center animate-fade" style="cursor:zoom-out">
          <button id="lightbox-close" class="absolute top-4 right-4 text-white p-2 hover:bg-white/20 rounded-full" style="z-index:51">
            <svg style="width:2rem;height:2rem" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
            </svg>
          </button>
          <img src="${state.lightboxImage}" class="max-w-full max-h-full object-contain p-4" style="cursor:default">
        </div>
      `;
    }

    function renderNewRequestModal() {
      return `
        <div id="modal-backdrop" class="modal-backdrop animate-fade">
          <div class="modal card p-6 animate-slide">
            <h2 class="text-xl font-bold text-primary mb-6">New Request</h2>
            <div class="space-y-4">
              <div>
                <label class="text-sm font-medium text-secondary mb-2" style="display:block">What do you need?</label>
                <input type="text" id="new-intent" placeholder="e.g., Check if the front door is locked" class="input">
              </div>
              <div>
                <label class="text-sm font-medium text-secondary mb-2" style="display:block">Context (optional)</label>
                <textarea id="new-context" placeholder="Any helpful details, one per line..." rows="3" class="input" style="resize:none"></textarea>
              </div>
              <div class="flex gap-4">
                <div class="flex-1">
                  <label class="text-sm font-medium text-secondary mb-2" style="display:block">Priority</label>
                  <select id="new-priority" class="input">
                    <option value="background">Background</option>
                    <option value="normal" selected>Normal</option>
                    <option value="elevated">Elevated</option>
                    <option value="urgent">Urgent</option>
                  </select>
                </div>
                <label class="flex items-center gap-2 cursor-pointer" style="padding-top:1.75rem">
                  <input type="checkbox" id="new-want-image">
                  <span class="text-sm text-secondary">ðŸ“· Want photo</span>
                </label>
              </div>
            </div>
            <div class="flex gap-3 mt-6">
              <button id="modal-cancel" class="btn btn-secondary flex-1">Cancel</button>
              <button id="modal-submit" class="btn btn-primary flex-1">Submit</button>
            </div>
          </div>
        </div>
      `;
    }

    // ============ Event Bindings ============
    function bindSetupEvents() {
      document.getElementById('theme-toggle')?.addEventListener('click', toggleTheme);
      document.getElementById('next-step')?.addEventListener('click', () => { state.setupStep++; state.error = null; render(); });
      document.getElementById('prev-step')?.addEventListener('click', () => { state.setupStep--; state.error = null; state.connectionTest = null; render(); });
      
      // Capability chip toggles
      document.querySelectorAll('.chip[data-cap]').forEach(chip => {
        chip.addEventListener('click', () => {
          const checkbox = chip.querySelector('input[type="checkbox"]');
          if (checkbox) {
            checkbox.checked = !checkbox.checked;
            chip.classList.toggle('selected', checkbox.checked);
          }
        });
      });
      
      document.getElementById('test-connection')?.addEventListener('click', async () => {
        const token = document.getElementById('input-token').value.trim();
        const repo = document.getElementById('input-repo').value.trim();
        if (!token || !repo) { state.error = 'Please enter both token and repository'; render(); return; }
        const [owner, repoName] = repo.split('/');
        if (!owner || !repoName) { state.error = 'Repository format: username/repo-name'; render(); return; }

        state.loading = true; state.error = null; state.connectionTest = null;
        state.config = { ...state.config, token, repo };
        render();

        try {
          const github = new GitHubExchange(owner, repoName, token);
          state.connectionTest = await github.testConnection();
        } catch (e) { state.error = e.message; }
        state.loading = false;
        render();
      });

      // Local mode: register executor with local server
      document.getElementById('register-local')?.addEventListener('click', async () => {
        const executorId = document.getElementById('input-local-executor-id').value.trim();
        const exchangeId = document.getElementById('input-exchange-id').value.trim() || 'home';
        if (!executorId) { state.error = 'Please enter an executor ID'; render(); return; }

        state.loading = true; state.error = null; state.connectionTest = null;
        render();

        try {
          const baseUrl = getApiBaseUrl();
          const res = await fetch(`${baseUrl}/api/v1/exchanges/${exchangeId}/register`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ executor_id: executorId })
          });

          const data = await res.json();
          if (!res.ok) {
            throw new Error(data.error || `Registration failed: ${res.status}`);
          }

          // Save the API key and config
          state.config = {
            ...state.config,
            token: data.api_key,
            executorId: data.executor_id,
            exchangeId: exchangeId
          };
          localStorage.setItem('mess-executor-config', JSON.stringify(state.config));

          state.connectionTest = { message: 'Save your API key: ' + data.api_key };
        } catch (e) {
          state.error = e.message;
        }
        state.loading = false;
        render();
      });

      document.getElementById('finish-setup')?.addEventListener('click', async () => {
        const executorId = document.getElementById('input-executor-id').value.trim();
        const displayName = document.getElementById('input-display-name').value.trim();
        const canRequest = document.getElementById('input-can-request').checked;
        const predefinedCaps = Array.from(document.querySelectorAll('.cap-checkbox:checked')).map(el => el.dataset.cap);
        const customCaps = parseCustomCapabilities(document.getElementById('input-custom-caps')?.value || '');
        const capabilities = [...new Set([...predefinedCaps, ...customCaps])];

        if (!executorId) { state.error = 'Please enter an executor name'; render(); return; }

        state.config = { ...state.config, executorId, displayName: displayName || executorId, canRequest, capabilities };
        localStorage.setItem('mess-executor-config', JSON.stringify(state.config));

        state.loading = true; render();

        if (state.isLocalMode) {
          // Local mode: use LocalApiExchange
          const baseUrl = getApiBaseUrl();
          const exchangeId = state.config.exchangeId || 'home';
          state.github = new LocalApiExchange(baseUrl, state.config.token, exchangeId);

          try {
            await state.github.registerExecutor({
              executor_id: executorId, display_name: displayName || executorId, capabilities
            });
          } catch (e) { console.log('Registration note:', e.message); }
        } else {
          // GitHub mode: use GitHubExchange
          const [owner, repo] = state.config.repo.split('/');
          state.github = new GitHubExchange(owner, repo, state.config.token);

          try {
            await state.github.registerExecutor({
              executor_id: executorId, display_name: displayName || executorId, capabilities,
              notifications: [], preferences: { min_priority: 'normal', quiet_hours: { enabled: false } }
            });
          } catch (e) { console.log('Registration note:', e.message); }
        }

        state.loading = false; state.view = 'main'; render(); refresh();
        startPeriodicSync();
      });
    }

    function bindSettingsEvents() {
      document.getElementById('back-to-main')?.addEventListener('click', () => { state.view = 'main'; render(); });
      document.getElementById('theme-toggle')?.addEventListener('click', toggleTheme);
      
      // Capability chip toggles
      document.querySelectorAll('.chip[data-cap]').forEach(chip => {
        chip.addEventListener('click', () => {
          const checkbox = chip.querySelector('input[type="checkbox"]');
          if (checkbox) {
            checkbox.checked = !checkbox.checked;
            chip.classList.toggle('selected', checkbox.checked);
          }
        });
      });
      
      document.getElementById('notif-type')?.addEventListener('change', (e) => {
        const configEl = document.getElementById('notif-config');
        if (e.target.value) {
          configEl.innerHTML = renderNotifConfig(e.target.value);
          configEl.classList.remove('hidden');
          bindNotifConfigEvents(e.target.value);
        } else { configEl.classList.add('hidden'); }
      });
      
      document.querySelectorAll('.remove-notif').forEach(btn => {
        btn.addEventListener('click', () => {
          state.config.notifications = state.config.notifications || [];
          state.config.notifications.splice(parseInt(btn.dataset.index), 1);
          render();
        });
      });
      
      document.getElementById('settings-quiet-hours')?.addEventListener('change', (e) => {
        document.getElementById('quiet-hours-config')?.classList.toggle('hidden', !e.target.checked);
      });
      
      document.getElementById('save-settings')?.addEventListener('click', async () => {
        const predefinedCaps = Array.from(document.querySelectorAll('.settings-cap:checked')).map(el => el.dataset.cap);
        const customCaps = parseCustomCapabilities(document.getElementById('settings-custom-caps')?.value || '');
        const capabilities = [...new Set([...predefinedCaps, ...customCaps])];
        const quietHoursEnabled = document.getElementById('settings-quiet-hours')?.checked;
        
        state.config = {
          ...state.config,
          repo: document.getElementById('settings-repo').value.trim(),
          token: document.getElementById('settings-token').value.trim(),
          executorId: document.getElementById('settings-executor-id').value.trim(),
          displayName: document.getElementById('settings-display-name').value.trim(),
          canRequest: document.getElementById('settings-can-request').checked,
          capabilities,
          preferences: {
            min_priority: document.getElementById('settings-min-priority')?.value || 'normal',
            quiet_hours: {
              enabled: quietHoursEnabled,
              start: document.getElementById('settings-quiet-start')?.value || '22:00',
              end: document.getElementById('settings-quiet-end')?.value || '07:00',
              timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
            }
          }
        };
        
        localStorage.setItem('mess-executor-config', JSON.stringify(state.config));
        const [owner, repo] = state.config.repo.split('/');
        state.github = new GitHubExchange(owner, repo, state.config.token);
        
        try {
          await state.github.registerExecutor({
            executor_id: state.config.executorId, display_name: state.config.displayName,
            capabilities: state.config.capabilities, notifications: state.config.notifications || [],
            preferences: state.config.preferences
          });
        } catch (e) { console.log('Update note:', e.message); }
        
        state.view = 'main'; render(); refresh();
      });
      
      document.getElementById('reset-settings')?.addEventListener('click', () => {
        if (confirm('This will clear all settings and start over. Continue?')) {
          localStorage.removeItem('mess-executor-config');
          state.config = null; state.github = null; state.connectionTest = null;
          state.view = 'setup'; state.setupStep = 1; render();
        }
      });
    }

    function bindNotifConfigEvents(type) {
      document.getElementById('add-notif-btn')?.addEventListener('click', () => {
        state.config.notifications = state.config.notifications || [];
        let notif = { type };
        
        switch (type) {
          case 'ntfy':
            notif.topic = document.getElementById('notif-ntfy-topic')?.value;
            const server = document.getElementById('notif-ntfy-server')?.value;
            if (server) notif.server = server;
            if (!notif.topic) return alert('Topic is required');
            break;
          case 'google_chat':
            notif.webhook_url = document.getElementById('notif-gchat-webhook')?.value;
            if (!notif.webhook_url) return alert('Webhook URL is required');
            break;
          case 'gmail':
            notif.to = document.getElementById('notif-gmail-to')?.value || null;
            break;
          case 'slack':
            notif.webhook_url = document.getElementById('notif-slack-webhook')?.value;
            if (!notif.webhook_url) return alert('Webhook URL is required');
            break;
          case 'pushover':
            notif.user_key = document.getElementById('notif-pushover-user')?.value;
            if (!notif.user_key) return alert('User key is required');
            break;
          case 'webhook':
            notif.url = document.getElementById('notif-webhook-url')?.value;
            if (!notif.url) return alert('Webhook URL is required');
            break;
        }
        
        state.config.notifications.push(notif);
        document.getElementById('notif-type').value = '';
        render();
      });
    }

    function bindMainEvents() {
      document.getElementById('refresh')?.addEventListener('click', refresh);
      document.getElementById('theme-toggle')?.addEventListener('click', toggleTheme);
      document.getElementById('open-settings')?.addEventListener('click', () => { state.view = 'settings'; render(); });
      document.getElementById('new-request')?.addEventListener('click', () => { state.showNewRequest = true; render(); });

      // Filter toggles
      document.getElementById('filter-capable')?.addEventListener('change', (e) => {
        state.filters.capableOnly = e.target.checked;
        render();
      });
      document.getElementById('filter-my-claims')?.addEventListener('change', (e) => {
        state.filters.myClaimsOnly = e.target.checked;
        render();
      });
      document.getElementById('filter-awaiting')?.addEventListener('change', (e) => {
        state.filters.awaitingAnswer = e.target.checked;
        render();
      });
      document.getElementById('filter-answered')?.addEventListener('change', (e) => {
        state.filters.hasNewAnswer = e.target.checked;
        render();
      });

      document.querySelectorAll('[data-folder]').forEach(tab => {
        tab.addEventListener('click', () => { state.currentFolder = tab.dataset.folder; state.selectedThread = null; render(); });
      });

      document.querySelectorAll('.thread-row').forEach(row => {
        row.addEventListener('click', (e) => {
          if (e.target.closest('.quick-claim') || e.target.closest('.quick-complete')) return;
          const allThreads = state.threads[state.currentFolder] || [];
          state.selectedThread = allThreads.find(t => t.ref === row.dataset.ref);
          render();
        });
      });

      document.querySelectorAll('.quick-claim').forEach(btn => {
        btn.addEventListener('click', async (e) => { e.stopPropagation(); await handleAction('claim', btn.dataset.ref); });
      });

      document.querySelectorAll('.quick-complete').forEach(btn => {
        btn.addEventListener('click', async (e) => { e.stopPropagation(); await handleAction('quick-complete', btn.dataset.ref); });
      });
    }

    function bindDetailEvents() {
      document.getElementById('back')?.addEventListener('click', () => { state.selectedThread = null; render(); });

      // Lightbox triggers for images
      document.querySelectorAll('.lightbox-trigger').forEach(img => {
        img.addEventListener('click', () => {
          state.lightboxImage = img.src;
          render();
        });
      });

      document.getElementById('action-claim')?.addEventListener('click', () => handleAction('claim'));
      document.getElementById('action-decline')?.addEventListener('click', () => handleAction('decline'));
      document.getElementById('action-needs-input-unclaimed')?.addEventListener('click', () => handleAction('needs_input_unclaimed'));
      document.getElementById('action-complete')?.addEventListener('click', () => handleAction('complete'));
      document.getElementById('action-failed')?.addEventListener('click', () => handleAction('failed'));
      document.getElementById('action-needs-input')?.addEventListener('click', () => handleAction('needs_input'));
      document.getElementById('action-more')?.addEventListener('click', () => {
        document.getElementById('main-actions')?.classList.add('hidden');
        document.getElementById('more-actions')?.classList.remove('hidden');
      });
      document.getElementById('action-back-to-main')?.addEventListener('click', () => {
        document.getElementById('more-actions')?.classList.add('hidden');
        document.getElementById('main-actions')?.classList.remove('hidden');
      });
      
      document.getElementById('photo-input')?.addEventListener('change', async (e) => {
        const file = e.target.files?.[0];
        if (file) {
          try {
            const compressedDataUrl = await compressImage(file);
            document.getElementById('photo-img').src = compressedDataUrl;
            document.getElementById('photo-preview').classList.remove('hidden');
          } catch (err) {
            console.error('Image compression failed:', err);
            alert('Failed to process image');
          }
        }
      });
      
      document.getElementById('remove-photo')?.addEventListener('click', () => {
        document.getElementById('photo-input').value = '';
        document.getElementById('photo-preview').classList.add('hidden');
      });

      // Location capture
      document.getElementById('location-btn')?.addEventListener('click', async () => {
        if (!navigator.geolocation) {
          alert('Geolocation is not supported by your browser');
          return;
        }

        const btn = document.getElementById('location-btn');
        btn.disabled = true;
        btn.textContent = 'â³';

        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 60000
            });
          });

          state.pendingLocation = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            accuracy: Math.round(position.coords.accuracy),
            timestamp: new Date().toISOString()
          };

          document.getElementById('location-text').textContent =
            `${state.pendingLocation.lat.toFixed(6)}, ${state.pendingLocation.lng.toFixed(6)} (Â±${state.pendingLocation.accuracy}m)`;
          document.getElementById('location-preview').classList.remove('hidden');
        } catch (err) {
          console.error('Location error:', err);
          alert('Failed to get location: ' + err.message);
        }

        btn.disabled = false;
        btn.textContent = 'ðŸ“';
      });

      document.getElementById('remove-location')?.addEventListener('click', () => {
        state.pendingLocation = null;
        document.getElementById('location-preview').classList.add('hidden');
      });

      // Audio recording
      document.getElementById('audio-btn')?.addEventListener('click', async () => {
        if (state.audioRecorder) {
          // Already recording - stop it
          state.audioRecorder.stop();
          return;
        }

        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
          const chunks = [];

          mediaRecorder.ondataavailable = (e) => chunks.push(e.data);

          mediaRecorder.onstop = async () => {
            stream.getTracks().forEach(track => track.stop());
            state.audioRecorder = null;
            clearInterval(state.audioTimer);
            document.getElementById('audio-recording').classList.add('hidden');
            document.getElementById('audio-btn').textContent = 'ðŸŽ¤';

            const blob = new Blob(chunks, { type: 'audio/webm' });

            // Convert to base64
            const reader = new FileReader();
            reader.onload = () => {
              state.pendingAudio = reader.result;
              document.getElementById('audio-player').src = reader.result;
              document.getElementById('audio-preview').classList.remove('hidden');
            };
            reader.readAsDataURL(blob);
          };

          state.audioRecorder = mediaRecorder;
          mediaRecorder.start();

          // Show recording UI
          document.getElementById('audio-recording').classList.remove('hidden');
          document.getElementById('audio-btn').textContent = 'â¹ï¸';

          // Duration timer
          let seconds = 0;
          state.audioTimer = setInterval(() => {
            seconds++;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            document.getElementById('audio-duration').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;

            // Auto-stop at 60 seconds
            if (seconds >= 60) {
              mediaRecorder.stop();
            }
          }, 1000);

        } catch (err) {
          console.error('Audio recording error:', err);
          alert('Failed to start recording: ' + err.message);
        }
      });

      document.getElementById('stop-audio')?.addEventListener('click', () => {
        if (state.audioRecorder) {
          state.audioRecorder.stop();
        }
      });

      document.getElementById('remove-audio')?.addEventListener('click', () => {
        state.pendingAudio = null;
        document.getElementById('audio-preview').classList.add('hidden');
      });

      // File attachment
      document.getElementById('file-input')?.addEventListener('change', async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;

        // Check file size (max 500KB for inline)
        const FILE_MAX_BYTES = 500000;
        if (file.size > FILE_MAX_BYTES) {
          alert(`File too large. Maximum size is ${Math.round(FILE_MAX_BYTES / 1024)}KB. Your file is ${Math.round(file.size / 1024)}KB.`);
          e.target.value = '';
          return;
        }

        try {
          const dataUrl = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(new Error('Failed to read file'));
            reader.readAsDataURL(file);
          });

          state.pendingFile = {
            name: file.name,
            type: file.type || 'application/octet-stream',
            size: file.size,
            data: dataUrl
          };

          // Update preview
          const icon = getFileIcon(file.type);
          document.getElementById('file-icon').textContent = icon;
          document.getElementById('file-name').textContent = file.name;
          document.getElementById('file-meta').textContent = `${file.type || 'Unknown type'} Â· ${formatFileSize(file.size)}`;
          document.getElementById('file-preview').classList.remove('hidden');
        } catch (err) {
          console.error('File read error:', err);
          alert('Failed to read file');
        }
      });

      document.getElementById('remove-file')?.addEventListener('click', () => {
        state.pendingFile = null;
        document.getElementById('file-input').value = '';
        document.getElementById('file-preview').classList.add('hidden');
      });
    }

    function getFileIcon(mimeType) {
      if (!mimeType) return 'ðŸ“„';
      if (mimeType.startsWith('image/')) return 'ðŸ–¼ï¸';
      if (mimeType.startsWith('video/')) return 'ðŸŽ¬';
      if (mimeType.startsWith('audio/')) return 'ðŸŽµ';
      if (mimeType.startsWith('text/')) return 'ðŸ“';
      if (mimeType.includes('pdf')) return 'ðŸ“•';
      if (mimeType.includes('zip') || mimeType.includes('compressed')) return 'ðŸ—œï¸';
      if (mimeType.includes('spreadsheet') || mimeType.includes('excel')) return 'ðŸ“Š';
      if (mimeType.includes('document') || mimeType.includes('word')) return 'ðŸ“˜';
      if (mimeType.includes('presentation') || mimeType.includes('powerpoint')) return 'ðŸ“™';
      return 'ðŸ“„';
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function bindLightboxEvents() {
      document.getElementById('lightbox-backdrop')?.addEventListener('click', (e) => {
        if (e.target.id === 'lightbox-backdrop') { state.lightboxImage = null; render(); }
      });
      document.getElementById('lightbox-close')?.addEventListener('click', () => {
        state.lightboxImage = null; render();
      });
      // Close on Escape key
      document.addEventListener('keydown', function lightboxEsc(e) {
        if (e.key === 'Escape' && state.lightboxImage) {
          state.lightboxImage = null;
          render();
          document.removeEventListener('keydown', lightboxEsc);
        }
      });
    }

    function bindNewRequestEvents() {
      document.getElementById('modal-backdrop')?.addEventListener('click', (e) => {
        if (e.target.id === 'modal-backdrop') { state.showNewRequest = false; render(); }
      });
      document.getElementById('modal-cancel')?.addEventListener('click', () => { state.showNewRequest = false; render(); });
      
      document.getElementById('modal-submit')?.addEventListener('click', async () => {
        const intent = document.getElementById('new-intent').value.trim();
        if (!intent) return;
        
        const context = document.getElementById('new-context').value.split('\n').filter(c => c.trim());
        const priority = document.getElementById('new-priority').value;
        const wantImage = document.getElementById('new-want-image').checked;
        
        state.loading = true; state.showNewRequest = false; render();
        
        try {
          await state.github.createRequest(state.config.executorId, {
            intent, context: context.length ? context : undefined, priority,
            response_hint: wantImage ? ['text', 'image'] : ['text']
          });
          await refresh();
        } catch (e) { console.error(e); alert('Failed to create request: ' + e.message); }
        
        state.loading = false; render();
      });
    }

    // ============ Actions ============

    // Apply optimistic updates to freshThreads based on recentlyModified tracking
    function applyOptimisticUpdates(freshThreads) {
      const now = Date.now();
      for (const [ref, entry] of state.recentlyModified) {
        if (entry.expires < now) {
          state.recentlyModified.delete(ref);
          continue;
        }

        // Check if the thread is already in the expected folder
        const inExpectedFolder = freshThreads[entry.folder]?.some(t => t.ref === ref);
        if (inExpectedFolder) {
          // GitHub caught up, remove from tracking
          state.recentlyModified.delete(ref);
          continue;
        }

        // Thread not in expected folder - check if it's elsewhere (stale)
        const folders = ['received', 'executing', 'finished', 'canceled'];
        for (const folder of folders) {
          const idx = freshThreads[folder]?.findIndex(t => t.ref === ref) ?? -1;
          if (idx !== -1) {
            // Remove from stale location
            freshThreads[folder].splice(idx, 1);
            break;
          }
        }

        // Add optimistic version to expected folder
        if (freshThreads[entry.folder]) {
          freshThreads[entry.folder].unshift(entry.thread);
        }
      }
    }

    async function refresh(forceInvalidate = true) {
      if (!state.github) return;
      state.loading = true; render();

      // Invalidate tree cache to get fresh data (default behavior)
      if (forceInvalidate) {
        state.github.invalidateTreeCache();
      }

      const folders = ['received', 'executing', 'finished', 'canceled'];
      const currentFolder = state.currentFolder;

      try {
        // Phase 1: Get tree discovery once (single API call for all folder/file listings)
        const discovery = await state.github.discoverThreads();

        // Phase 2: Load current folder first for fast initial render
        const currentThreads = await state.github.listThreadsForFolder(currentFolder, discovery);

        // Update just the current folder and render immediately
        const partialThreads = { ...state.threads, [currentFolder]: currentThreads };
        applyOptimisticUpdates(partialThreads);
        state.threads = partialThreads;
        state.loading = false;
        render();

        // Phase 3: Load remaining folders in parallel (discovery is already cached)
        const otherFolders = folders.filter(f => f !== currentFolder);
        const otherResults = await Promise.all(
          otherFolders.map(async (folder) => {
            try {
              return { folder, threads: await state.github.listThreadsForFolder(folder, discovery) };
            } catch (e) {
              console.error(`Failed to load ${folder}:`, e);
              return { folder, threads: state.threads[folder] || [] };
            }
          })
        );

        // Update all folders at once
        const allThreads = { ...state.threads };
        for (const { folder, threads } of otherResults) {
          allThreads[folder] = threads;
        }
        applyOptimisticUpdates(allThreads);
        state.threads = allThreads;
        render();
      } catch (e) {
        console.error('Refresh failed:', e);
        state.loading = false;
        render();
      }
    }

    // Optimistically move a thread between folders in local state
    function moveThreadLocally(thread, oldFolder, newFolder, newStatus) {
      // Remove from old folder
      const oldIndex = state.threads[oldFolder].findIndex(t => t.ref === thread.ref);
      if (oldIndex !== -1) {
        state.threads[oldFolder].splice(oldIndex, 1);
      }

      // Update thread properties including _path for the new location
      const newPath = `exchange/state=${newFolder}/${thread.ref}`;
      const updatedThread = {
        ...thread,
        status: newStatus,
        updated: new Date().toISOString(),
        executor: newStatus === 'claimed' ? state.config.executorId : thread.executor,
        _path: newPath  // Critical: update path so subsequent operations use correct location
      };
      if (updatedThread.envelope) {
        updatedThread.envelope = { ...updatedThread.envelope, status: newStatus, updated: updatedThread.updated };
        if (newStatus === 'claimed') updatedThread.envelope.executor = state.config.executorId;
      }

      // Add to new folder (at the beginning since it's most recently updated)
      state.threads[newFolder].unshift(updatedThread);

      // Track this modification to preserve during refresh (10 second window)
      state.recentlyModified.set(thread.ref, {
        folder: newFolder,
        thread: updatedThread,
        expires: Date.now() + 10000
      });

      return updatedThread;
    }

    async function handleAction(action, refOverride = null) {
      const thread = refOverride
        ? state.threads[state.currentFolder].find(t => t.ref === refOverride)
        : state.selectedThread;
      if (!thread) return;

      // Check if this thread is claimed by another executor
      const myId = state.config?.executorId;
      const claimedBy = thread.messages?.find(m =>
        m.MESS?.some(item => item.status?.code === 'claimed' && item.status?.executor)
      )?.MESS?.find(item => item.status?.code === 'claimed')?.status?.executor;

      if (claimedBy && claimedBy !== myId && ['complete', 'failed', 'needs_input'].includes(action)) {
        const proceed = confirm(`This request is claimed by "${claimedBy}". Are you sure you want to ${action === 'complete' ? 'complete' : action === 'failed' ? 'mark as failed' : 'request input on'} it?`);
        if (!proceed) return;
      }

      // Capture form values and pending attachments BEFORE render() clears them
      const responseText = document.getElementById('response-text')?.value;
      const photoImg = document.getElementById('photo-img')?.src;
      const pendingLocation = state.pendingLocation;
      const pendingAudio = state.pendingAudio;
      const pendingFile = state.pendingFile;

      // Clear pending attachments
      state.pendingLocation = null;
      state.pendingAudio = null;
      state.pendingFile = null;

      // Determine state transition
      let mess = [], newStatus = null;
      const ref = thread.ref;

      if (action === 'claim') { mess = [{ status: { re: ref, code: 'claimed' } }]; newStatus = 'claimed'; }
      else if (action === 'complete') {
        mess = [{ status: { re: ref, code: 'completed' } }];
        const content = [];
        if (photoImg && !photoImg.startsWith('about:')) content.push({ image: photoImg });
        if (pendingLocation) content.push({ location: pendingLocation });
        if (pendingAudio) content.push({ audio: pendingAudio });
        if (pendingFile) content.push({ file: pendingFile });
        if (responseText) content.push(responseText);
        if (content.length) mess.push({ response: { re: ref, content } });
        newStatus = 'completed';
      }
      else if (action === 'quick-complete') {
        // Claim and complete in one action (no response content)
        mess = [
          { status: { re: ref, code: 'claimed' } },
          { status: { re: ref, code: 'completed' } }
        ];
        newStatus = 'completed';
      }
      else if (action === 'failed') { mess = [{ status: { re: ref, code: 'failed' } }]; newStatus = 'failed'; }
      else if (action === 'decline') { mess = [{ status: { re: ref, code: 'declined' } }]; newStatus = 'declined'; }
      else if (action === 'needs_input') {
        const question = responseText || 'Need more information';
        mess = [{ status: { re: ref, code: 'needs_input', message: question } }];
        newStatus = 'needs_input';
      }
      else if (action === 'needs_input_unclaimed') {
        // Claim and request info in one action
        const question = responseText || 'Need more information';
        mess = [
          { status: { re: ref, code: 'claimed' } },
          { status: { re: ref, code: 'needs_input', message: question } }
        ];
        newStatus = 'needs_input';
      }

      // Optimistically update local state before API call
      const oldFolder = state.currentFolder;
      const newFolder = state.github.getFolder(newStatus);

      // For claim action, stay on detail view and show response form immediately
      // For other actions, close detail view
      const stayOnDetail = (action === 'claim');

      if (!stayOnDetail) {
        state.selectedThread = null;
      }
      state.loading = true;

      // Move thread locally for instant feedback
      let updatedThread = thread;
      if (newStatus && newFolder !== oldFolder) {
        updatedThread = moveThreadLocally(thread, oldFolder, newFolder, newStatus);
        // Switch to new folder so user sees the thread
        if (stayOnDetail) {
          state.currentFolder = newFolder;
        }
      } else if (newStatus) {
        // Update in place if staying in same folder
        const idx = state.threads[oldFolder].findIndex(t => t.ref === thread.ref);
        if (idx !== -1) {
          updatedThread = { ...thread, status: newStatus, updated: new Date().toISOString() };
          if (updatedThread.envelope) {
            updatedThread.envelope = { ...updatedThread.envelope, status: newStatus };
          }
          state.threads[oldFolder][idx] = updatedThread;
          // Track this modification to preserve during refresh
          state.recentlyModified.set(thread.ref, {
            folder: oldFolder,
            thread: updatedThread,
            expires: Date.now() + 10000
          });
        }
      }

      // Keep selected thread updated if staying on detail
      if (stayOnDetail) {
        state.selectedThread = updatedThread;
      }

      render();

      try {
        await state.github.updateThread(thread, state.config.executorId, mess, newStatus);
        state.loading = false;
        render();
        // Background refresh to sync with server (don't block UI)
        refresh().catch(e => console.error('Background refresh failed:', e));
      } catch (e) {
        console.error(e);
        state.loading = false;
        // Show error but don't alert() which is disruptive - use a toast or inline message
        state.error = 'Action failed: ' + e.message;
        // Clear optimistic tracking so refresh gets actual state
        state.recentlyModified.delete(thread.ref);
        // Revert optimistic update on failure - do a full refresh
        await refresh();
        // Clear error after refresh shows actual state
        setTimeout(() => { state.error = null; render(); }, 3000);
      }
    }

    function formatTime(isoString) {
      if (!isoString) return '';
      const date = new Date(isoString);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      if (diffMins < 1) return 'just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      return date.toLocaleDateString();
    }

    init();

    // Register service worker for PWA support
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', async () => {
        try {
          const registration = await navigator.serviceWorker.register('./sw.js');
          console.log('[PWA] Service worker registered:', registration.scope);

          // Listen for messages from service worker
          navigator.serviceWorker.addEventListener('message', (event) => {
            if (event.data.type === 'SYNC_COMPLETE') {
              console.log('[PWA] Sync complete, refreshing...');
              if (window.app?.refresh) window.app.refresh();
            }
            if (event.data.type === 'NOTIFICATION_CLICK' && event.data.ref) {
              console.log('[PWA] Notification clicked:', event.data.ref);
              // Could navigate to specific thread here
            }
          });
        } catch (error) {
          console.error('[PWA] Service worker registration failed:', error);
        }
      });
    }
  </script>
</body>
</html>
